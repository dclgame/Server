// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgShare.proto

#ifndef PROTOBUF_MsgShare_2eproto__INCLUDED
#define PROTOBUF_MsgShare_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Define.pb.h"
#include "MsgBase.pb.h"
// @@protoc_insertion_point(includes)

namespace Msg {

// Internal implementation detail -- do not call these.
void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
void protobuf_AssignDesc_MsgShare_2eproto();
void protobuf_ShutdownFile_MsgShare_2eproto();

class ReqEnterGameServer;
class ReqAckEnterGameSuccess;
class ReqHeartBeat;
class ReqLeaveGameServer;
class PlayerEntryIo;
class AckPlayerEntryList;
class AckPlayerLeaveList;
class ReqAckSynData;
class ReqAckPlayerMove;
class ReqAckPlayerChat;
class ReqAckPlayerChat_ChatContainer;
class EffectData;
class ReqAckUseSkill;
class ReqAckUseItem;
class ReqAckSwapScene;
class ReqAckHomeScene;
class ItemStruct;
class CurrencyStruct;
class ReqAckStartBattle;
class ReqEndBattle;
class AckEndBattle;
class ReqPickDropItem;
class ReqAcceptTask;
class ReqCompeleteTask;
class ReqWearEquip;
class TakeOffEquip;
class ReqAckJoinActivity;
class ReqAckCreateGuild;
class ReqSearchGuild;
class AckSearchGuild;
class AckSearchGuild_SearchGuildObject;
class ReqAckJoinGuild;
class ReqAckLeaveGuild;
class ReqAckOprGuildMember;
class ReqEnterGuildEctype;
class ReqIntensifylevelToEquip;
class AckIntensifylevelToEquip;
class ReqHoleToEquip;
class AckHoleToEquip;
class ReqInlaystoneToEquip;
class AckInlaystoneToEquip;
class ReqElementlevelToEquip;
class AckElementlevelToEquip;
class ReqSetFightHero;
class ReqSwitchFightHero;
class ReqMiningTitle;
class TileState;
class TileBuilding;
class TileNPC;
class AckMiningTitle;
class ReqSearchOppnent;
class AckSearchOppnent;
class ReqSendMail;
class ReqSwitchServer;
class AckSwitchServer;
class TeamIo;
class TeammemberIo;
class ReqAckCreateTeam;
class ReqAckJoinTeam;
class ReqAckLeaveTeam;
class ReqAckOprTeamMember;
class ReqAckInviteTeam;
class ReqTeamEnterEctype;
class AckTeamEnterEctype;
class GridGuildBaseIo;
class ReqBigMapGridIo;
class BigMapGridBaseIo;
class BigMapLeaveMsg;
class BigMapWarHistory;
class BigMapGridDetailIo;
class AckBigMapGridIo;
class ReqBigMapIo;
class AckBigMapIo;
class ReqHoldMapGrid;
class AckHoldMapGrid;
class ReqLeaveMapMsg;
class AckLeaveMapMsg;
class ReqGetMapAward;
class AckGetMapAward;
class ReqMapHunting;
class AckMapHunting;
class ReqMapKingWar;
class AckMapKingWar;
class PVPRoomIo;
class ReqPVPApplyMatch;
class AckPVPApplyMatch;
class ReqCreatePVPEctype;
class AckCreatePVPEctype;

enum ReqAckSynData_SynType {
  ReqAckSynData_SynType_EST_GROUP = 1,
  ReqAckSynData_SynType_EST_SCENE = 2,
  ReqAckSynData_SynType_EST_GUILD = 3,
  ReqAckSynData_SynType_EST_FRIEND = 4
};
LIBPROTOC_EXPORT bool ReqAckSynData_SynType_IsValid(int value);
const ReqAckSynData_SynType ReqAckSynData_SynType_SynType_MIN = ReqAckSynData_SynType_EST_GROUP;
const ReqAckSynData_SynType ReqAckSynData_SynType_SynType_MAX = ReqAckSynData_SynType_EST_FRIEND;
const int ReqAckSynData_SynType_SynType_ARRAYSIZE = ReqAckSynData_SynType_SynType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckSynData_SynType_descriptor();
inline const ::std::string& ReqAckSynData_SynType_Name(ReqAckSynData_SynType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckSynData_SynType_descriptor(), value);
}
inline bool ReqAckSynData_SynType_Parse(
    const ::std::string& name, ReqAckSynData_SynType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckSynData_SynType>(
    ReqAckSynData_SynType_descriptor(), name, value);
}
enum ReqAckPlayerChat_ChatContainer_ContainerType {
  ReqAckPlayerChat_ChatContainer_ContainerType_EGCT_ITEM = 1
};
LIBPROTOC_EXPORT bool ReqAckPlayerChat_ChatContainer_ContainerType_IsValid(int value);
const ReqAckPlayerChat_ChatContainer_ContainerType ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_MIN = ReqAckPlayerChat_ChatContainer_ContainerType_EGCT_ITEM;
const ReqAckPlayerChat_ChatContainer_ContainerType ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_MAX = ReqAckPlayerChat_ChatContainer_ContainerType_EGCT_ITEM;
const int ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_ARRAYSIZE = ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckPlayerChat_ChatContainer_ContainerType_descriptor();
inline const ::std::string& ReqAckPlayerChat_ChatContainer_ContainerType_Name(ReqAckPlayerChat_ChatContainer_ContainerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckPlayerChat_ChatContainer_ContainerType_descriptor(), value);
}
inline bool ReqAckPlayerChat_ChatContainer_ContainerType_Parse(
    const ::std::string& name, ReqAckPlayerChat_ChatContainer_ContainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckPlayerChat_ChatContainer_ContainerType>(
    ReqAckPlayerChat_ChatContainer_ContainerType_descriptor(), name, value);
}
enum ReqAckPlayerChat_EGameChatType {
  ReqAckPlayerChat_EGameChatType_EGCT_GUILD = 0,
  ReqAckPlayerChat_EGameChatType_EGCT_PRIVATE = 1,
  ReqAckPlayerChat_EGameChatType_EGCT_TEAM = 2,
  ReqAckPlayerChat_EGameChatType_EGCT_WORLD = 3
};
LIBPROTOC_EXPORT bool ReqAckPlayerChat_EGameChatType_IsValid(int value);
const ReqAckPlayerChat_EGameChatType ReqAckPlayerChat_EGameChatType_EGameChatType_MIN = ReqAckPlayerChat_EGameChatType_EGCT_GUILD;
const ReqAckPlayerChat_EGameChatType ReqAckPlayerChat_EGameChatType_EGameChatType_MAX = ReqAckPlayerChat_EGameChatType_EGCT_WORLD;
const int ReqAckPlayerChat_EGameChatType_EGameChatType_ARRAYSIZE = ReqAckPlayerChat_EGameChatType_EGameChatType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckPlayerChat_EGameChatType_descriptor();
inline const ::std::string& ReqAckPlayerChat_EGameChatType_Name(ReqAckPlayerChat_EGameChatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckPlayerChat_EGameChatType_descriptor(), value);
}
inline bool ReqAckPlayerChat_EGameChatType_Parse(
    const ::std::string& name, ReqAckPlayerChat_EGameChatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckPlayerChat_EGameChatType>(
    ReqAckPlayerChat_EGameChatType_descriptor(), name, value);
}
enum EffectData_EResultType {
  EffectData_EResultType_EET_FAIL = 0,
  EffectData_EResultType_EET_SUCCESS = 1,
  EffectData_EResultType_EET_REFUSE = 2,
  EffectData_EResultType_EET_MISS = 3,
  EffectData_EResultType_EET_CRIT = 4
};
LIBPROTOC_EXPORT bool EffectData_EResultType_IsValid(int value);
const EffectData_EResultType EffectData_EResultType_EResultType_MIN = EffectData_EResultType_EET_FAIL;
const EffectData_EResultType EffectData_EResultType_EResultType_MAX = EffectData_EResultType_EET_CRIT;
const int EffectData_EResultType_EResultType_ARRAYSIZE = EffectData_EResultType_EResultType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* EffectData_EResultType_descriptor();
inline const ::std::string& EffectData_EResultType_Name(EffectData_EResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EffectData_EResultType_descriptor(), value);
}
inline bool EffectData_EResultType_Parse(
    const ::std::string& name, EffectData_EResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EffectData_EResultType>(
    EffectData_EResultType_descriptor(), name, value);
}
enum ReqAckSwapScene_EGameSwapType {
  ReqAckSwapScene_EGameSwapType_EGST_NARMAL = 0,
  ReqAckSwapScene_EGameSwapType_EGST_CLONE = 1,
  ReqAckSwapScene_EGameSwapType_EGST_ARENA = 2,
  ReqAckSwapScene_EGameSwapType_EGST_MIRROR = 3
};
LIBPROTOC_EXPORT bool ReqAckSwapScene_EGameSwapType_IsValid(int value);
const ReqAckSwapScene_EGameSwapType ReqAckSwapScene_EGameSwapType_EGameSwapType_MIN = ReqAckSwapScene_EGameSwapType_EGST_NARMAL;
const ReqAckSwapScene_EGameSwapType ReqAckSwapScene_EGameSwapType_EGameSwapType_MAX = ReqAckSwapScene_EGameSwapType_EGST_MIRROR;
const int ReqAckSwapScene_EGameSwapType_EGameSwapType_ARRAYSIZE = ReqAckSwapScene_EGameSwapType_EGameSwapType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckSwapScene_EGameSwapType_descriptor();
inline const ::std::string& ReqAckSwapScene_EGameSwapType_Name(ReqAckSwapScene_EGameSwapType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckSwapScene_EGameSwapType_descriptor(), value);
}
inline bool ReqAckSwapScene_EGameSwapType_Parse(
    const ::std::string& name, ReqAckSwapScene_EGameSwapType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckSwapScene_EGameSwapType>(
    ReqAckSwapScene_EGameSwapType_descriptor(), name, value);
}
enum ReqAckJoinActivity_EGameActivityType {
  ReqAckJoinActivity_EGameActivityType_EGAT_PVP = 0
};
LIBPROTOC_EXPORT bool ReqAckJoinActivity_EGameActivityType_IsValid(int value);
const ReqAckJoinActivity_EGameActivityType ReqAckJoinActivity_EGameActivityType_EGameActivityType_MIN = ReqAckJoinActivity_EGameActivityType_EGAT_PVP;
const ReqAckJoinActivity_EGameActivityType ReqAckJoinActivity_EGameActivityType_EGameActivityType_MAX = ReqAckJoinActivity_EGameActivityType_EGAT_PVP;
const int ReqAckJoinActivity_EGameActivityType_EGameActivityType_ARRAYSIZE = ReqAckJoinActivity_EGameActivityType_EGameActivityType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckJoinActivity_EGameActivityType_descriptor();
inline const ::std::string& ReqAckJoinActivity_EGameActivityType_Name(ReqAckJoinActivity_EGameActivityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckJoinActivity_EGameActivityType_descriptor(), value);
}
inline bool ReqAckJoinActivity_EGameActivityType_Parse(
    const ::std::string& name, ReqAckJoinActivity_EGameActivityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckJoinActivity_EGameActivityType>(
    ReqAckJoinActivity_EGameActivityType_descriptor(), name, value);
}
enum ReqAckJoinActivity_EGameActivitySubType {
  ReqAckJoinActivity_EGameActivitySubType_EGAT_NORMAL = 0
};
LIBPROTOC_EXPORT bool ReqAckJoinActivity_EGameActivitySubType_IsValid(int value);
const ReqAckJoinActivity_EGameActivitySubType ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_MIN = ReqAckJoinActivity_EGameActivitySubType_EGAT_NORMAL;
const ReqAckJoinActivity_EGameActivitySubType ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_MAX = ReqAckJoinActivity_EGameActivitySubType_EGAT_NORMAL;
const int ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_ARRAYSIZE = ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckJoinActivity_EGameActivitySubType_descriptor();
inline const ::std::string& ReqAckJoinActivity_EGameActivitySubType_Name(ReqAckJoinActivity_EGameActivitySubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckJoinActivity_EGameActivitySubType_descriptor(), value);
}
inline bool ReqAckJoinActivity_EGameActivitySubType_Parse(
    const ::std::string& name, ReqAckJoinActivity_EGameActivitySubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckJoinActivity_EGameActivitySubType>(
    ReqAckJoinActivity_EGameActivitySubType_descriptor(), name, value);
}
enum ReqAckOprGuildMember_EGGuildMemberOprType {
  ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_DOWN = 0,
  ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_UP = 1,
  ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_KICK = 2
};
LIBPROTOC_EXPORT bool ReqAckOprGuildMember_EGGuildMemberOprType_IsValid(int value);
const ReqAckOprGuildMember_EGGuildMemberOprType ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_MIN = ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_DOWN;
const ReqAckOprGuildMember_EGGuildMemberOprType ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_MAX = ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_KICK;
const int ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_ARRAYSIZE = ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckOprGuildMember_EGGuildMemberOprType_descriptor();
inline const ::std::string& ReqAckOprGuildMember_EGGuildMemberOprType_Name(ReqAckOprGuildMember_EGGuildMemberOprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckOprGuildMember_EGGuildMemberOprType_descriptor(), value);
}
inline bool ReqAckOprGuildMember_EGGuildMemberOprType_Parse(
    const ::std::string& name, ReqAckOprGuildMember_EGGuildMemberOprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckOprGuildMember_EGGuildMemberOprType>(
    ReqAckOprGuildMember_EGGuildMemberOprType_descriptor(), name, value);
}
enum ReqAckOprTeamMember_EGTeamMemberOprType {
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN = 0,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_UP = 1,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICK = 2,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_APPOINT = 3,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_FIRE = 4,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DEMISE = 5,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_ACCEPTAPPLY = 6,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DENYAPPLY = 7,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT = 8
};
LIBPROTOC_EXPORT bool ReqAckOprTeamMember_EGTeamMemberOprType_IsValid(int value);
const ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MIN = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN;
const ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT;
const int ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_ARRAYSIZE = ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
inline const ::std::string& ReqAckOprTeamMember_EGTeamMemberOprType_Name(ReqAckOprTeamMember_EGTeamMemberOprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckOprTeamMember_EGTeamMemberOprType_descriptor(), value);
}
inline bool ReqAckOprTeamMember_EGTeamMemberOprType_Parse(
    const ::std::string& name, ReqAckOprTeamMember_EGTeamMemberOprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckOprTeamMember_EGTeamMemberOprType>(
    ReqAckOprTeamMember_EGTeamMemberOprType_descriptor(), name, value);
}
enum ReqPVPApplyMatch_EApplyType {
  ReqPVPApplyMatch_EApplyType_EApplyType_Single = 0,
  ReqPVPApplyMatch_EApplyType_EApplyType_Team = 1
};
LIBPROTOC_EXPORT bool ReqPVPApplyMatch_EApplyType_IsValid(int value);
const ReqPVPApplyMatch_EApplyType ReqPVPApplyMatch_EApplyType_EApplyType_MIN = ReqPVPApplyMatch_EApplyType_EApplyType_Single;
const ReqPVPApplyMatch_EApplyType ReqPVPApplyMatch_EApplyType_EApplyType_MAX = ReqPVPApplyMatch_EApplyType_EApplyType_Team;
const int ReqPVPApplyMatch_EApplyType_EApplyType_ARRAYSIZE = ReqPVPApplyMatch_EApplyType_EApplyType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqPVPApplyMatch_EApplyType_descriptor();
inline const ::std::string& ReqPVPApplyMatch_EApplyType_Name(ReqPVPApplyMatch_EApplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqPVPApplyMatch_EApplyType_descriptor(), value);
}
inline bool ReqPVPApplyMatch_EApplyType_Parse(
    const ::std::string& name, ReqPVPApplyMatch_EApplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqPVPApplyMatch_EApplyType>(
    ReqPVPApplyMatch_EApplyType_descriptor(), name, value);
}
// ===================================================================

class LIBPROTOC_EXPORT ReqEnterGameServer : public ::google::protobuf::Message {
 public:
  ReqEnterGameServer();
  virtual ~ReqEnterGameServer();

  ReqEnterGameServer(const ReqEnterGameServer& from);

  inline ReqEnterGameServer& operator=(const ReqEnterGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEnterGameServer& default_instance();

  void Swap(ReqEnterGameServer* other);

  // implements Message ----------------------------------------------

  ReqEnterGameServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEnterGameServer& from);
  void MergeFrom(const ReqEnterGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Msg::Ident& id() const;
  inline ::Msg::Ident* mutable_id();
  inline ::Msg::Ident* release_id();
  inline void set_allocated_id(::Msg::Ident* id);

  // required bytes account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required int32 game_id = 3;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::int32 game_id() const;
  inline void set_game_id(::google::protobuf::int32 value);

  // required bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Msg.ReqEnterGameServer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* id_;
  ::std::string* account_;
  ::std::string* name_;
  ::google::protobuf::int32 game_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqEnterGameServer* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckEnterGameSuccess : public ::google::protobuf::Message {
 public:
  ReqAckEnterGameSuccess();
  virtual ~ReqAckEnterGameSuccess();

  ReqAckEnterGameSuccess(const ReqAckEnterGameSuccess& from);

  inline ReqAckEnterGameSuccess& operator=(const ReqAckEnterGameSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckEnterGameSuccess& default_instance();

  void Swap(ReqAckEnterGameSuccess* other);

  // implements Message ----------------------------------------------

  ReqAckEnterGameSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckEnterGameSuccess& from);
  void MergeFrom(const ReqAckEnterGameSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqAckEnterGameSuccess)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckEnterGameSuccess* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqHeartBeat : public ::google::protobuf::Message {
 public:
  ReqHeartBeat();
  virtual ~ReqHeartBeat();

  ReqHeartBeat(const ReqHeartBeat& from);

  inline ReqHeartBeat& operator=(const ReqHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHeartBeat& default_instance();

  void Swap(ReqHeartBeat* other);

  // implements Message ----------------------------------------------

  ReqHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHeartBeat& from);
  void MergeFrom(const ReqHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqHeartBeat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqLeaveGameServer : public ::google::protobuf::Message {
 public:
  ReqLeaveGameServer();
  virtual ~ReqLeaveGameServer();

  ReqLeaveGameServer(const ReqLeaveGameServer& from);

  inline ReqLeaveGameServer& operator=(const ReqLeaveGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLeaveGameServer& default_instance();

  void Swap(ReqLeaveGameServer* other);

  // implements Message ----------------------------------------------

  ReqLeaveGameServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLeaveGameServer& from);
  void MergeFrom(const ReqLeaveGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqLeaveGameServer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqLeaveGameServer* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PlayerEntryIo : public ::google::protobuf::Message {
 public:
  PlayerEntryIo();
  virtual ~PlayerEntryIo();

  PlayerEntryIo(const PlayerEntryIo& from);

  inline PlayerEntryIo& operator=(const PlayerEntryIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerEntryIo& default_instance();

  void Swap(PlayerEntryIo* other);

  // implements Message ----------------------------------------------

  PlayerEntryIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerEntryIo& from);
  void MergeFrom(const PlayerEntryIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident object_guid = 1;
  inline bool has_object_guid() const;
  inline void clear_object_guid();
  static const int kObjectGuidFieldNumber = 1;
  inline const ::Msg::Ident& object_guid() const;
  inline ::Msg::Ident* mutable_object_guid();
  inline ::Msg::Ident* release_object_guid();
  inline void set_allocated_object_guid(::Msg::Ident* object_guid);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 4;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline float z() const;
  inline void set_z(float value);

  // required int32 career_type = 5;
  inline bool has_career_type() const;
  inline void clear_career_type();
  static const int kCareerTypeFieldNumber = 5;
  inline ::google::protobuf::int32 career_type() const;
  inline void set_career_type(::google::protobuf::int32 value);

  // required int32 player_state = 6;
  inline bool has_player_state() const;
  inline void clear_player_state();
  static const int kPlayerStateFieldNumber = 6;
  inline ::google::protobuf::int32 player_state() const;
  inline void set_player_state(::google::protobuf::int32 value);

  // required bytes coig_id = 7;
  inline bool has_coig_id() const;
  inline void clear_coig_id();
  static const int kCoigIdFieldNumber = 7;
  inline const ::std::string& coig_id() const;
  inline void set_coig_id(const ::std::string& value);
  inline void set_coig_id(const char* value);
  inline void set_coig_id(const void* value, size_t size);
  inline ::std::string* mutable_coig_id();
  inline ::std::string* release_coig_id();
  inline void set_allocated_coig_id(::std::string* coig_id);

  // required int32 scene_id = 8;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 8;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // required bytes class_id = 9;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 9;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const void* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // @@protoc_insertion_point(class_scope:Msg.PlayerEntryIo)
 private:
  inline void set_has_object_guid();
  inline void clear_has_object_guid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_career_type();
  inline void clear_has_career_type();
  inline void set_has_player_state();
  inline void clear_has_player_state();
  inline void set_has_coig_id();
  inline void clear_has_coig_id();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_class_id();
  inline void clear_has_class_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* object_guid_;
  float x_;
  float y_;
  float z_;
  ::google::protobuf::int32 career_type_;
  ::std::string* coig_id_;
  ::google::protobuf::int32 player_state_;
  ::google::protobuf::int32 scene_id_;
  ::std::string* class_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static PlayerEntryIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckPlayerEntryList : public ::google::protobuf::Message {
 public:
  AckPlayerEntryList();
  virtual ~AckPlayerEntryList();

  AckPlayerEntryList(const AckPlayerEntryList& from);

  inline AckPlayerEntryList& operator=(const AckPlayerEntryList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPlayerEntryList& default_instance();

  void Swap(AckPlayerEntryList* other);

  // implements Message ----------------------------------------------

  AckPlayerEntryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPlayerEntryList& from);
  void MergeFrom(const AckPlayerEntryList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Msg.PlayerEntryIo object_list = 1;
  inline int object_list_size() const;
  inline void clear_object_list();
  static const int kObjectListFieldNumber = 1;
  inline const ::Msg::PlayerEntryIo& object_list(int index) const;
  inline ::Msg::PlayerEntryIo* mutable_object_list(int index);
  inline ::Msg::PlayerEntryIo* add_object_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::PlayerEntryIo >&
      object_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::PlayerEntryIo >*
      mutable_object_list();

  // @@protoc_insertion_point(class_scope:Msg.AckPlayerEntryList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::PlayerEntryIo > object_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckPlayerEntryList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckPlayerLeaveList : public ::google::protobuf::Message {
 public:
  AckPlayerLeaveList();
  virtual ~AckPlayerLeaveList();

  AckPlayerLeaveList(const AckPlayerLeaveList& from);

  inline AckPlayerLeaveList& operator=(const AckPlayerLeaveList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPlayerLeaveList& default_instance();

  void Swap(AckPlayerLeaveList* other);

  // implements Message ----------------------------------------------

  AckPlayerLeaveList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPlayerLeaveList& from);
  void MergeFrom(const AckPlayerLeaveList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Msg.Ident object_list = 1;
  inline int object_list_size() const;
  inline void clear_object_list();
  static const int kObjectListFieldNumber = 1;
  inline const ::Msg::Ident& object_list(int index) const;
  inline ::Msg::Ident* mutable_object_list(int index);
  inline ::Msg::Ident* add_object_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
      object_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
      mutable_object_list();

  // @@protoc_insertion_point(class_scope:Msg.AckPlayerLeaveList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::Ident > object_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckPlayerLeaveList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckSynData : public ::google::protobuf::Message {
 public:
  ReqAckSynData();
  virtual ~ReqAckSynData();

  ReqAckSynData(const ReqAckSynData& from);

  inline ReqAckSynData& operator=(const ReqAckSynData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckSynData& default_instance();

  void Swap(ReqAckSynData* other);

  // implements Message ----------------------------------------------

  ReqAckSynData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckSynData& from);
  void MergeFrom(const ReqAckSynData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckSynData_SynType SynType;
  static const SynType EST_GROUP = ReqAckSynData_SynType_EST_GROUP;
  static const SynType EST_SCENE = ReqAckSynData_SynType_EST_SCENE;
  static const SynType EST_GUILD = ReqAckSynData_SynType_EST_GUILD;
  static const SynType EST_FRIEND = ReqAckSynData_SynType_EST_FRIEND;
  static inline bool SynType_IsValid(int value) {
    return ReqAckSynData_SynType_IsValid(value);
  }
  static const SynType SynType_MIN =
    ReqAckSynData_SynType_SynType_MIN;
  static const SynType SynType_MAX =
    ReqAckSynData_SynType_SynType_MAX;
  static const int SynType_ARRAYSIZE =
    ReqAckSynData_SynType_SynType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SynType_descriptor() {
    return ReqAckSynData_SynType_descriptor();
  }
  static inline const ::std::string& SynType_Name(SynType value) {
    return ReqAckSynData_SynType_Name(value);
  }
  static inline bool SynType_Parse(const ::std::string& name,
      SynType* value) {
    return ReqAckSynData_SynType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident syser = 1;
  inline bool has_syser() const;
  inline void clear_syser();
  static const int kSyserFieldNumber = 1;
  inline const ::Msg::Ident& syser() const;
  inline ::Msg::Ident* mutable_syser();
  inline ::Msg::Ident* release_syser();
  inline void set_allocated_syser(::Msg::Ident* syser);

  // repeated .Msg.Ident object_list = 2;
  inline int object_list_size() const;
  inline void clear_object_list();
  static const int kObjectListFieldNumber = 2;
  inline const ::Msg::Ident& object_list(int index) const;
  inline ::Msg::Ident* mutable_object_list(int index);
  inline ::Msg::Ident* add_object_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
      object_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
      mutable_object_list();

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required .Msg.ReqAckSynData.SynType syn_type = 4;
  inline bool has_syn_type() const;
  inline void clear_syn_type();
  static const int kSynTypeFieldNumber = 4;
  inline ::Msg::ReqAckSynData_SynType syn_type() const;
  inline void set_syn_type(::Msg::ReqAckSynData_SynType value);

  // required .Msg.ESynMsgID msg_id = 5;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 5;
  inline ::Msg::ESynMsgID msg_id() const;
  inline void set_msg_id(::Msg::ESynMsgID value);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckSynData)
 private:
  inline void set_has_syser();
  inline void clear_has_syser();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_syn_type();
  inline void clear_has_syn_type();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* syser_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Ident > object_list_;
  ::std::string* data_;
  int syn_type_;
  int msg_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckSynData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckPlayerMove : public ::google::protobuf::Message {
 public:
  ReqAckPlayerMove();
  virtual ~ReqAckPlayerMove();

  ReqAckPlayerMove(const ReqAckPlayerMove& from);

  inline ReqAckPlayerMove& operator=(const ReqAckPlayerMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckPlayerMove& default_instance();

  void Swap(ReqAckPlayerMove* other);

  // implements Message ----------------------------------------------

  ReqAckPlayerMove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckPlayerMove& from);
  void MergeFrom(const ReqAckPlayerMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident mover = 1;
  inline bool has_mover() const;
  inline void clear_mover();
  static const int kMoverFieldNumber = 1;
  inline const ::Msg::Ident& mover() const;
  inline ::Msg::Ident* mutable_mover();
  inline ::Msg::Ident* release_mover();
  inline void set_allocated_mover(::Msg::Ident* mover);

  // required int32 moveType = 2;
  inline bool has_movetype() const;
  inline void clear_movetype();
  static const int kMoveTypeFieldNumber = 2;
  inline ::google::protobuf::int32 movetype() const;
  inline void set_movetype(::google::protobuf::int32 value);

  // required float speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // required int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // repeated .Msg.Vector3 target_pos = 5;
  inline int target_pos_size() const;
  inline void clear_target_pos();
  static const int kTargetPosFieldNumber = 5;
  inline const ::Msg::Vector3& target_pos(int index) const;
  inline ::Msg::Vector3* mutable_target_pos(int index);
  inline ::Msg::Vector3* add_target_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
      target_pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
      mutable_target_pos();

  // repeated .Msg.Vector3 source_pos = 6;
  inline int source_pos_size() const;
  inline void clear_source_pos();
  static const int kSourcePosFieldNumber = 6;
  inline const ::Msg::Vector3& source_pos(int index) const;
  inline ::Msg::Vector3* mutable_source_pos(int index);
  inline ::Msg::Vector3* add_source_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
      source_pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
      mutable_source_pos();

  // repeated .Msg.Vector3 move_direction = 7;
  inline int move_direction_size() const;
  inline void clear_move_direction();
  static const int kMoveDirectionFieldNumber = 7;
  inline const ::Msg::Vector3& move_direction(int index) const;
  inline ::Msg::Vector3* mutable_move_direction(int index);
  inline ::Msg::Vector3* add_move_direction();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
      move_direction() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
      mutable_move_direction();

  // @@protoc_insertion_point(class_scope:Msg.ReqAckPlayerMove)
 private:
  inline void set_has_mover();
  inline void clear_has_mover();
  inline void set_has_movetype();
  inline void clear_has_movetype();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* mover_;
  ::google::protobuf::int32 movetype_;
  float speed_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 > target_pos_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 > source_pos_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 > move_direction_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckPlayerMove* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckPlayerChat_ChatContainer : public ::google::protobuf::Message {
 public:
  ReqAckPlayerChat_ChatContainer();
  virtual ~ReqAckPlayerChat_ChatContainer();

  ReqAckPlayerChat_ChatContainer(const ReqAckPlayerChat_ChatContainer& from);

  inline ReqAckPlayerChat_ChatContainer& operator=(const ReqAckPlayerChat_ChatContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckPlayerChat_ChatContainer& default_instance();

  void Swap(ReqAckPlayerChat_ChatContainer* other);

  // implements Message ----------------------------------------------

  ReqAckPlayerChat_ChatContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckPlayerChat_ChatContainer& from);
  void MergeFrom(const ReqAckPlayerChat_ChatContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckPlayerChat_ChatContainer_ContainerType ContainerType;
  static const ContainerType EGCT_ITEM = ReqAckPlayerChat_ChatContainer_ContainerType_EGCT_ITEM;
  static inline bool ContainerType_IsValid(int value) {
    return ReqAckPlayerChat_ChatContainer_ContainerType_IsValid(value);
  }
  static const ContainerType ContainerType_MIN =
    ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_MIN;
  static const ContainerType ContainerType_MAX =
    ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_MAX;
  static const int ContainerType_ARRAYSIZE =
    ReqAckPlayerChat_ChatContainer_ContainerType_ContainerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContainerType_descriptor() {
    return ReqAckPlayerChat_ChatContainer_ContainerType_descriptor();
  }
  static inline const ::std::string& ContainerType_Name(ContainerType value) {
    return ReqAckPlayerChat_ChatContainer_ContainerType_Name(value);
  }
  static inline bool ContainerType_Parse(const ::std::string& name,
      ContainerType* value) {
    return ReqAckPlayerChat_ChatContainer_ContainerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 ConTainerType = 2;
  inline bool has_containertype() const;
  inline void clear_containertype();
  static const int kConTainerTypeFieldNumber = 2;
  inline ::google::protobuf::int32 containertype() const;
  inline void set_containertype(::google::protobuf::int32 value);

  // required bytes data_io = 3;
  inline bool has_data_io() const;
  inline void clear_data_io();
  static const int kDataIoFieldNumber = 3;
  inline const ::std::string& data_io() const;
  inline void set_data_io(const ::std::string& value);
  inline void set_data_io(const char* value);
  inline void set_data_io(const void* value, size_t size);
  inline ::std::string* mutable_data_io();
  inline ::std::string* release_data_io();
  inline void set_allocated_data_io(::std::string* data_io);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckPlayerChat.ChatContainer)
 private:
  inline void set_has_containertype();
  inline void clear_has_containertype();
  inline void set_has_data_io();
  inline void clear_has_data_io();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_io_;
  ::google::protobuf::int32 containertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckPlayerChat_ChatContainer* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckPlayerChat : public ::google::protobuf::Message {
 public:
  ReqAckPlayerChat();
  virtual ~ReqAckPlayerChat();

  ReqAckPlayerChat(const ReqAckPlayerChat& from);

  inline ReqAckPlayerChat& operator=(const ReqAckPlayerChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckPlayerChat& default_instance();

  void Swap(ReqAckPlayerChat* other);

  // implements Message ----------------------------------------------

  ReqAckPlayerChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckPlayerChat& from);
  void MergeFrom(const ReqAckPlayerChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckPlayerChat_ChatContainer ChatContainer;

  typedef ReqAckPlayerChat_EGameChatType EGameChatType;
  static const EGameChatType EGCT_GUILD = ReqAckPlayerChat_EGameChatType_EGCT_GUILD;
  static const EGameChatType EGCT_PRIVATE = ReqAckPlayerChat_EGameChatType_EGCT_PRIVATE;
  static const EGameChatType EGCT_TEAM = ReqAckPlayerChat_EGameChatType_EGCT_TEAM;
  static const EGameChatType EGCT_WORLD = ReqAckPlayerChat_EGameChatType_EGCT_WORLD;
  static inline bool EGameChatType_IsValid(int value) {
    return ReqAckPlayerChat_EGameChatType_IsValid(value);
  }
  static const EGameChatType EGameChatType_MIN =
    ReqAckPlayerChat_EGameChatType_EGameChatType_MIN;
  static const EGameChatType EGameChatType_MAX =
    ReqAckPlayerChat_EGameChatType_EGameChatType_MAX;
  static const int EGameChatType_ARRAYSIZE =
    ReqAckPlayerChat_EGameChatType_EGameChatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGameChatType_descriptor() {
    return ReqAckPlayerChat_EGameChatType_descriptor();
  }
  static inline const ::std::string& EGameChatType_Name(EGameChatType value) {
    return ReqAckPlayerChat_EGameChatType_Name(value);
  }
  static inline bool EGameChatType_Parse(const ::std::string& name,
      EGameChatType* value) {
    return ReqAckPlayerChat_EGameChatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident chat_id = 1;
  inline bool has_chat_id() const;
  inline void clear_chat_id();
  static const int kChatIdFieldNumber = 1;
  inline const ::Msg::Ident& chat_id() const;
  inline ::Msg::Ident* mutable_chat_id();
  inline ::Msg::Ident* release_chat_id();
  inline void set_allocated_chat_id(::Msg::Ident* chat_id);

  // required .Msg.ReqAckPlayerChat.EGameChatType chat_type = 2;
  inline bool has_chat_type() const;
  inline void clear_chat_type();
  static const int kChatTypeFieldNumber = 2;
  inline ::Msg::ReqAckPlayerChat_EGameChatType chat_type() const;
  inline void set_chat_type(::Msg::ReqAckPlayerChat_EGameChatType value);

  // required bytes chat_io = 3;
  inline bool has_chat_io() const;
  inline void clear_chat_io();
  static const int kChatIoFieldNumber = 3;
  inline const ::std::string& chat_io() const;
  inline void set_chat_io(const ::std::string& value);
  inline void set_chat_io(const char* value);
  inline void set_chat_io(const void* value, size_t size);
  inline ::std::string* mutable_chat_io();
  inline ::std::string* release_chat_io();
  inline void set_allocated_chat_io(::std::string* chat_io);

  // required bytes chat_name = 4;
  inline bool has_chat_name() const;
  inline void clear_chat_name();
  static const int kChatNameFieldNumber = 4;
  inline const ::std::string& chat_name() const;
  inline void set_chat_name(const ::std::string& value);
  inline void set_chat_name(const char* value);
  inline void set_chat_name(const void* value, size_t size);
  inline ::std::string* mutable_chat_name();
  inline ::std::string* release_chat_name();
  inline void set_allocated_chat_name(::std::string* chat_name);

  // optional .Msg.Ident target_id = 5;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 5;
  inline const ::Msg::Ident& target_id() const;
  inline ::Msg::Ident* mutable_target_id();
  inline ::Msg::Ident* release_target_id();
  inline void set_allocated_target_id(::Msg::Ident* target_id);

  // repeated .Msg.ReqAckPlayerChat.ChatContainer Container_data = 6;
  inline int container_data_size() const;
  inline void clear_container_data();
  static const int kContainerDataFieldNumber = 6;
  inline const ::Msg::ReqAckPlayerChat_ChatContainer& container_data(int index) const;
  inline ::Msg::ReqAckPlayerChat_ChatContainer* mutable_container_data(int index);
  inline ::Msg::ReqAckPlayerChat_ChatContainer* add_container_data();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::ReqAckPlayerChat_ChatContainer >&
      container_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::ReqAckPlayerChat_ChatContainer >*
      mutable_container_data();

  // @@protoc_insertion_point(class_scope:Msg.ReqAckPlayerChat)
 private:
  inline void set_has_chat_id();
  inline void clear_has_chat_id();
  inline void set_has_chat_type();
  inline void clear_has_chat_type();
  inline void set_has_chat_io();
  inline void clear_has_chat_io();
  inline void set_has_chat_name();
  inline void clear_has_chat_name();
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* chat_id_;
  ::std::string* chat_io_;
  ::std::string* chat_name_;
  ::Msg::Ident* target_id_;
  ::google::protobuf::RepeatedPtrField< ::Msg::ReqAckPlayerChat_ChatContainer > container_data_;
  int chat_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckPlayerChat* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT EffectData : public ::google::protobuf::Message {
 public:
  EffectData();
  virtual ~EffectData();

  EffectData(const EffectData& from);

  inline EffectData& operator=(const EffectData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectData& default_instance();

  void Swap(EffectData* other);

  // implements Message ----------------------------------------------

  EffectData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EffectData& from);
  void MergeFrom(const EffectData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EffectData_EResultType EResultType;
  static const EResultType EET_FAIL = EffectData_EResultType_EET_FAIL;
  static const EResultType EET_SUCCESS = EffectData_EResultType_EET_SUCCESS;
  static const EResultType EET_REFUSE = EffectData_EResultType_EET_REFUSE;
  static const EResultType EET_MISS = EffectData_EResultType_EET_MISS;
  static const EResultType EET_CRIT = EffectData_EResultType_EET_CRIT;
  static inline bool EResultType_IsValid(int value) {
    return EffectData_EResultType_IsValid(value);
  }
  static const EResultType EResultType_MIN =
    EffectData_EResultType_EResultType_MIN;
  static const EResultType EResultType_MAX =
    EffectData_EResultType_EResultType_MAX;
  static const int EResultType_ARRAYSIZE =
    EffectData_EResultType_EResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResultType_descriptor() {
    return EffectData_EResultType_descriptor();
  }
  static inline const ::std::string& EResultType_Name(EResultType value) {
    return EffectData_EResultType_Name(value);
  }
  static inline bool EResultType_Parse(const ::std::string& name,
      EResultType* value) {
    return EffectData_EResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident effect_ident = 1;
  inline bool has_effect_ident() const;
  inline void clear_effect_ident();
  static const int kEffectIdentFieldNumber = 1;
  inline const ::Msg::Ident& effect_ident() const;
  inline ::Msg::Ident* mutable_effect_ident();
  inline ::Msg::Ident* release_effect_ident();
  inline void set_allocated_effect_ident(::Msg::Ident* effect_ident);

  // required int32 effect_value = 2;
  inline bool has_effect_value() const;
  inline void clear_effect_value();
  static const int kEffectValueFieldNumber = 2;
  inline ::google::protobuf::int32 effect_value() const;
  inline void set_effect_value(::google::protobuf::int32 value);

  // required .Msg.EffectData.EResultType effect_rlt = 3;
  inline bool has_effect_rlt() const;
  inline void clear_effect_rlt();
  static const int kEffectRltFieldNumber = 3;
  inline ::Msg::EffectData_EResultType effect_rlt() const;
  inline void set_effect_rlt(::Msg::EffectData_EResultType value);

  // @@protoc_insertion_point(class_scope:Msg.EffectData)
 private:
  inline void set_has_effect_ident();
  inline void clear_has_effect_ident();
  inline void set_has_effect_value();
  inline void clear_has_effect_value();
  inline void set_has_effect_rlt();
  inline void clear_has_effect_rlt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* effect_ident_;
  ::google::protobuf::int32 effect_value_;
  int effect_rlt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static EffectData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckUseSkill : public ::google::protobuf::Message {
 public:
  ReqAckUseSkill();
  virtual ~ReqAckUseSkill();

  ReqAckUseSkill(const ReqAckUseSkill& from);

  inline ReqAckUseSkill& operator=(const ReqAckUseSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckUseSkill& default_instance();

  void Swap(ReqAckUseSkill* other);

  // implements Message ----------------------------------------------

  ReqAckUseSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckUseSkill& from);
  void MergeFrom(const ReqAckUseSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::Msg::Ident& user() const;
  inline ::Msg::Ident* mutable_user();
  inline ::Msg::Ident* release_user();
  inline void set_allocated_user(::Msg::Ident* user);

  // required bytes skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline const ::std::string& skill_id() const;
  inline void set_skill_id(const ::std::string& value);
  inline void set_skill_id(const char* value);
  inline void set_skill_id(const void* value, size_t size);
  inline ::std::string* mutable_skill_id();
  inline ::std::string* release_skill_id();
  inline void set_allocated_skill_id(::std::string* skill_id);

  // required int32 use_index = 3;
  inline bool has_use_index() const;
  inline void clear_use_index();
  static const int kUseIndexFieldNumber = 3;
  inline ::google::protobuf::int32 use_index() const;
  inline void set_use_index(::google::protobuf::int32 value);

  // repeated .Msg.EffectData effect_data = 4;
  inline int effect_data_size() const;
  inline void clear_effect_data();
  static const int kEffectDataFieldNumber = 4;
  inline const ::Msg::EffectData& effect_data(int index) const;
  inline ::Msg::EffectData* mutable_effect_data(int index);
  inline ::Msg::EffectData* add_effect_data();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >&
      effect_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >*
      mutable_effect_data();

  // @@protoc_insertion_point(class_scope:Msg.ReqAckUseSkill)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_use_index();
  inline void clear_has_use_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* user_;
  ::std::string* skill_id_;
  ::google::protobuf::RepeatedPtrField< ::Msg::EffectData > effect_data_;
  ::google::protobuf::int32 use_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckUseSkill* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckUseItem : public ::google::protobuf::Message {
 public:
  ReqAckUseItem();
  virtual ~ReqAckUseItem();

  ReqAckUseItem(const ReqAckUseItem& from);

  inline ReqAckUseItem& operator=(const ReqAckUseItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckUseItem& default_instance();

  void Swap(ReqAckUseItem* other);

  // implements Message ----------------------------------------------

  ReqAckUseItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckUseItem& from);
  void MergeFrom(const ReqAckUseItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::Msg::Ident& user() const;
  inline ::Msg::Ident* mutable_user();
  inline ::Msg::Ident* release_user();
  inline void set_allocated_user(::Msg::Ident* user);

  // required .Msg.Ident item_guid = 2;
  inline bool has_item_guid() const;
  inline void clear_item_guid();
  static const int kItemGuidFieldNumber = 2;
  inline const ::Msg::Ident& item_guid() const;
  inline ::Msg::Ident* mutable_item_guid();
  inline ::Msg::Ident* release_item_guid();
  inline void set_allocated_item_guid(::Msg::Ident* item_guid);

  // repeated .Msg.EffectData effect_data = 3;
  inline int effect_data_size() const;
  inline void clear_effect_data();
  static const int kEffectDataFieldNumber = 3;
  inline const ::Msg::EffectData& effect_data(int index) const;
  inline ::Msg::EffectData* mutable_effect_data(int index);
  inline ::Msg::EffectData* add_effect_data();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >&
      effect_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >*
      mutable_effect_data();

  // required .Msg.ItemStruct item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::Msg::ItemStruct& item() const;
  inline ::Msg::ItemStruct* mutable_item();
  inline ::Msg::ItemStruct* release_item();
  inline void set_allocated_item(::Msg::ItemStruct* item);

  // required .Msg.Ident targetid = 5;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetidFieldNumber = 5;
  inline const ::Msg::Ident& targetid() const;
  inline ::Msg::Ident* mutable_targetid();
  inline ::Msg::Ident* release_targetid();
  inline void set_allocated_targetid(::Msg::Ident* targetid);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckUseItem)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_item_guid();
  inline void clear_has_item_guid();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* user_;
  ::Msg::Ident* item_guid_;
  ::google::protobuf::RepeatedPtrField< ::Msg::EffectData > effect_data_;
  ::Msg::ItemStruct* item_;
  ::Msg::Ident* targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckUseItem* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckSwapScene : public ::google::protobuf::Message {
 public:
  ReqAckSwapScene();
  virtual ~ReqAckSwapScene();

  ReqAckSwapScene(const ReqAckSwapScene& from);

  inline ReqAckSwapScene& operator=(const ReqAckSwapScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckSwapScene& default_instance();

  void Swap(ReqAckSwapScene* other);

  // implements Message ----------------------------------------------

  ReqAckSwapScene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckSwapScene& from);
  void MergeFrom(const ReqAckSwapScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckSwapScene_EGameSwapType EGameSwapType;
  static const EGameSwapType EGST_NARMAL = ReqAckSwapScene_EGameSwapType_EGST_NARMAL;
  static const EGameSwapType EGST_CLONE = ReqAckSwapScene_EGameSwapType_EGST_CLONE;
  static const EGameSwapType EGST_ARENA = ReqAckSwapScene_EGameSwapType_EGST_ARENA;
  static const EGameSwapType EGST_MIRROR = ReqAckSwapScene_EGameSwapType_EGST_MIRROR;
  static inline bool EGameSwapType_IsValid(int value) {
    return ReqAckSwapScene_EGameSwapType_IsValid(value);
  }
  static const EGameSwapType EGameSwapType_MIN =
    ReqAckSwapScene_EGameSwapType_EGameSwapType_MIN;
  static const EGameSwapType EGameSwapType_MAX =
    ReqAckSwapScene_EGameSwapType_EGameSwapType_MAX;
  static const int EGameSwapType_ARRAYSIZE =
    ReqAckSwapScene_EGameSwapType_EGameSwapType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGameSwapType_descriptor() {
    return ReqAckSwapScene_EGameSwapType_descriptor();
  }
  static inline const ::std::string& EGameSwapType_Name(EGameSwapType value) {
    return ReqAckSwapScene_EGameSwapType_Name(value);
  }
  static inline bool EGameSwapType_Parse(const ::std::string& name,
      EGameSwapType* value) {
    return ReqAckSwapScene_EGameSwapType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.ReqAckSwapScene.EGameSwapType transfer_type = 1;
  inline bool has_transfer_type() const;
  inline void clear_transfer_type();
  static const int kTransferTypeFieldNumber = 1;
  inline ::Msg::ReqAckSwapScene_EGameSwapType transfer_type() const;
  inline void set_transfer_type(::Msg::ReqAckSwapScene_EGameSwapType value);

  // required int32 scene_id = 2;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 2;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // required int32 line_id = 3;
  inline bool has_line_id() const;
  inline void clear_line_id();
  static const int kLineIdFieldNumber = 3;
  inline ::google::protobuf::int32 line_id() const;
  inline void set_line_id(::google::protobuf::int32 value);

  // optional float x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 6;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 6;
  inline float z() const;
  inline void set_z(float value);

  // optional string data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckSwapScene)
 private:
  inline void set_has_transfer_type();
  inline void clear_has_transfer_type();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_line_id();
  inline void clear_has_line_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int transfer_type_;
  ::google::protobuf::int32 scene_id_;
  ::google::protobuf::int32 line_id_;
  float x_;
  float y_;
  float z_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckSwapScene* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckHomeScene : public ::google::protobuf::Message {
 public:
  ReqAckHomeScene();
  virtual ~ReqAckHomeScene();

  ReqAckHomeScene(const ReqAckHomeScene& from);

  inline ReqAckHomeScene& operator=(const ReqAckHomeScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckHomeScene& default_instance();

  void Swap(ReqAckHomeScene* other);

  // implements Message ----------------------------------------------

  ReqAckHomeScene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckHomeScene& from);
  void MergeFrom(const ReqAckHomeScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckHomeScene)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckHomeScene* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ItemStruct : public ::google::protobuf::Message {
 public:
  ItemStruct();
  virtual ~ItemStruct();

  ItemStruct(const ItemStruct& from);

  inline ItemStruct& operator=(const ItemStruct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemStruct& default_instance();

  void Swap(ItemStruct* other);

  // implements Message ----------------------------------------------

  ItemStruct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemStruct& from);
  void MergeFrom(const ItemStruct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline const ::std::string& item_id() const;
  inline void set_item_id(const ::std::string& value);
  inline void set_item_id(const char* value);
  inline void set_item_id(const char* value, size_t size);
  inline ::std::string* mutable_item_id();
  inline ::std::string* release_item_id();
  inline void set_allocated_item_id(::std::string* item_id);

  // required int32 item_count = 2;
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 2;
  inline ::google::protobuf::int32 item_count() const;
  inline void set_item_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ItemStruct)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_count();
  inline void clear_has_item_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* item_id_;
  ::google::protobuf::int32 item_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ItemStruct* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT CurrencyStruct : public ::google::protobuf::Message {
 public:
  CurrencyStruct();
  virtual ~CurrencyStruct();

  CurrencyStruct(const CurrencyStruct& from);

  inline CurrencyStruct& operator=(const CurrencyStruct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrencyStruct& default_instance();

  void Swap(CurrencyStruct* other);

  // implements Message ----------------------------------------------

  CurrencyStruct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrencyStruct& from);
  void MergeFrom(const CurrencyStruct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 currency_type = 1;
  inline bool has_currency_type() const;
  inline void clear_currency_type();
  static const int kCurrencyTypeFieldNumber = 1;
  inline ::google::protobuf::int32 currency_type() const;
  inline void set_currency_type(::google::protobuf::int32 value);

  // required int32 currency_count = 2;
  inline bool has_currency_count() const;
  inline void clear_currency_count();
  static const int kCurrencyCountFieldNumber = 2;
  inline ::google::protobuf::int32 currency_count() const;
  inline void set_currency_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.CurrencyStruct)
 private:
  inline void set_has_currency_type();
  inline void clear_has_currency_type();
  inline void set_has_currency_count();
  inline void clear_has_currency_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 currency_type_;
  ::google::protobuf::int32 currency_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static CurrencyStruct* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckStartBattle : public ::google::protobuf::Message {
 public:
  ReqAckStartBattle();
  virtual ~ReqAckStartBattle();

  ReqAckStartBattle(const ReqAckStartBattle& from);

  inline ReqAckStartBattle& operator=(const ReqAckStartBattle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckStartBattle& default_instance();

  void Swap(ReqAckStartBattle* other);

  // implements Message ----------------------------------------------

  ReqAckStartBattle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckStartBattle& from);
  void MergeFrom(const ReqAckStartBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // required int32 diamond = 2;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 2;
  inline ::google::protobuf::int32 diamond() const;
  inline void set_diamond(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckStartBattle)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 diamond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckStartBattle* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqEndBattle : public ::google::protobuf::Message {
 public:
  ReqEndBattle();
  virtual ~ReqEndBattle();

  ReqEndBattle(const ReqEndBattle& from);

  inline ReqEndBattle& operator=(const ReqEndBattle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEndBattle& default_instance();

  void Swap(ReqEndBattle* other);

  // implements Message ----------------------------------------------

  ReqEndBattle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEndBattle& from);
  void MergeFrom(const ReqEndBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqEndBattle)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqEndBattle* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckEndBattle : public ::google::protobuf::Message {
 public:
  AckEndBattle();
  virtual ~AckEndBattle();

  AckEndBattle(const AckEndBattle& from);

  inline AckEndBattle& operator=(const AckEndBattle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEndBattle& default_instance();

  void Swap(AckEndBattle* other);

  // implements Message ----------------------------------------------

  AckEndBattle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEndBattle& from);
  void MergeFrom(const AckEndBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 win = 1;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 1;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);

  // required int32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // required int32 gold = 3;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 3;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // required int32 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // required int32 diamond = 5;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 5;
  inline ::google::protobuf::int32 diamond() const;
  inline void set_diamond(::google::protobuf::int32 value);

  // repeated .Msg.ItemStruct item_list = 6;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 6;
  inline const ::Msg::ItemStruct& item_list(int index) const;
  inline ::Msg::ItemStruct* mutable_item_list(int index);
  inline ::Msg::ItemStruct* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Msg.AckEndBattle)
 private:
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 win_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct > item_list_;
  ::google::protobuf::int32 diamond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckEndBattle* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqPickDropItem : public ::google::protobuf::Message {
 public:
  ReqPickDropItem();
  virtual ~ReqPickDropItem();

  ReqPickDropItem(const ReqPickDropItem& from);

  inline ReqPickDropItem& operator=(const ReqPickDropItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPickDropItem& default_instance();

  void Swap(ReqPickDropItem* other);

  // implements Message ----------------------------------------------

  ReqPickDropItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPickDropItem& from);
  void MergeFrom(const ReqPickDropItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident item_guid = 2;
  inline bool has_item_guid() const;
  inline void clear_item_guid();
  static const int kItemGuidFieldNumber = 2;
  inline const ::Msg::Ident& item_guid() const;
  inline ::Msg::Ident* mutable_item_guid();
  inline ::Msg::Ident* release_item_guid();
  inline void set_allocated_item_guid(::Msg::Ident* item_guid);

  // @@protoc_insertion_point(class_scope:Msg.ReqPickDropItem)
 private:
  inline void set_has_item_guid();
  inline void clear_has_item_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* item_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqPickDropItem* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAcceptTask : public ::google::protobuf::Message {
 public:
  ReqAcceptTask();
  virtual ~ReqAcceptTask();

  ReqAcceptTask(const ReqAcceptTask& from);

  inline ReqAcceptTask& operator=(const ReqAcceptTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAcceptTask& default_instance();

  void Swap(ReqAcceptTask* other);

  // implements Message ----------------------------------------------

  ReqAcceptTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAcceptTask& from);
  void MergeFrom(const ReqAcceptTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const void* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqAcceptTask)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAcceptTask* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqCompeleteTask : public ::google::protobuf::Message {
 public:
  ReqCompeleteTask();
  virtual ~ReqCompeleteTask();

  ReqCompeleteTask(const ReqCompeleteTask& from);

  inline ReqCompeleteTask& operator=(const ReqCompeleteTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCompeleteTask& default_instance();

  void Swap(ReqCompeleteTask* other);

  // implements Message ----------------------------------------------

  ReqCompeleteTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCompeleteTask& from);
  void MergeFrom(const ReqCompeleteTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const void* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqCompeleteTask)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqCompeleteTask* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqWearEquip : public ::google::protobuf::Message {
 public:
  ReqWearEquip();
  virtual ~ReqWearEquip();

  ReqWearEquip(const ReqWearEquip& from);

  inline ReqWearEquip& operator=(const ReqWearEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqWearEquip& default_instance();

  void Swap(ReqWearEquip* other);

  // implements Message ----------------------------------------------

  ReqWearEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqWearEquip& from);
  void MergeFrom(const ReqWearEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required .Msg.Ident Targetid = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetidFieldNumber = 2;
  inline const ::Msg::Ident& targetid() const;
  inline ::Msg::Ident* mutable_targetid();
  inline ::Msg::Ident* release_targetid();
  inline void set_allocated_targetid(::Msg::Ident* targetid);

  // @@protoc_insertion_point(class_scope:Msg.ReqWearEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::Msg::Ident* targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqWearEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TakeOffEquip : public ::google::protobuf::Message {
 public:
  TakeOffEquip();
  virtual ~TakeOffEquip();

  TakeOffEquip(const TakeOffEquip& from);

  inline TakeOffEquip& operator=(const TakeOffEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TakeOffEquip& default_instance();

  void Swap(TakeOffEquip* other);

  // implements Message ----------------------------------------------

  TakeOffEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TakeOffEquip& from);
  void MergeFrom(const TakeOffEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required .Msg.Ident Targetid = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetidFieldNumber = 2;
  inline const ::Msg::Ident& targetid() const;
  inline ::Msg::Ident* mutable_targetid();
  inline ::Msg::Ident* release_targetid();
  inline void set_allocated_targetid(::Msg::Ident* targetid);

  // @@protoc_insertion_point(class_scope:Msg.TakeOffEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::Msg::Ident* targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TakeOffEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckJoinActivity : public ::google::protobuf::Message {
 public:
  ReqAckJoinActivity();
  virtual ~ReqAckJoinActivity();

  ReqAckJoinActivity(const ReqAckJoinActivity& from);

  inline ReqAckJoinActivity& operator=(const ReqAckJoinActivity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckJoinActivity& default_instance();

  void Swap(ReqAckJoinActivity* other);

  // implements Message ----------------------------------------------

  ReqAckJoinActivity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckJoinActivity& from);
  void MergeFrom(const ReqAckJoinActivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckJoinActivity_EGameActivityType EGameActivityType;
  static const EGameActivityType EGAT_PVP = ReqAckJoinActivity_EGameActivityType_EGAT_PVP;
  static inline bool EGameActivityType_IsValid(int value) {
    return ReqAckJoinActivity_EGameActivityType_IsValid(value);
  }
  static const EGameActivityType EGameActivityType_MIN =
    ReqAckJoinActivity_EGameActivityType_EGameActivityType_MIN;
  static const EGameActivityType EGameActivityType_MAX =
    ReqAckJoinActivity_EGameActivityType_EGameActivityType_MAX;
  static const int EGameActivityType_ARRAYSIZE =
    ReqAckJoinActivity_EGameActivityType_EGameActivityType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGameActivityType_descriptor() {
    return ReqAckJoinActivity_EGameActivityType_descriptor();
  }
  static inline const ::std::string& EGameActivityType_Name(EGameActivityType value) {
    return ReqAckJoinActivity_EGameActivityType_Name(value);
  }
  static inline bool EGameActivityType_Parse(const ::std::string& name,
      EGameActivityType* value) {
    return ReqAckJoinActivity_EGameActivityType_Parse(name, value);
  }

  typedef ReqAckJoinActivity_EGameActivitySubType EGameActivitySubType;
  static const EGameActivitySubType EGAT_NORMAL = ReqAckJoinActivity_EGameActivitySubType_EGAT_NORMAL;
  static inline bool EGameActivitySubType_IsValid(int value) {
    return ReqAckJoinActivity_EGameActivitySubType_IsValid(value);
  }
  static const EGameActivitySubType EGameActivitySubType_MIN =
    ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_MIN;
  static const EGameActivitySubType EGameActivitySubType_MAX =
    ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_MAX;
  static const int EGameActivitySubType_ARRAYSIZE =
    ReqAckJoinActivity_EGameActivitySubType_EGameActivitySubType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGameActivitySubType_descriptor() {
    return ReqAckJoinActivity_EGameActivitySubType_descriptor();
  }
  static inline const ::std::string& EGameActivitySubType_Name(EGameActivitySubType value) {
    return ReqAckJoinActivity_EGameActivitySubType_Name(value);
  }
  static inline bool EGameActivitySubType_Parse(const ::std::string& name,
      EGameActivitySubType* value) {
    return ReqAckJoinActivity_EGameActivitySubType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.ReqAckJoinActivity.EGameActivityType activity_type = 1;
  inline bool has_activity_type() const;
  inline void clear_activity_type();
  static const int kActivityTypeFieldNumber = 1;
  inline ::Msg::ReqAckJoinActivity_EGameActivityType activity_type() const;
  inline void set_activity_type(::Msg::ReqAckJoinActivity_EGameActivityType value);

  // required .Msg.ReqAckJoinActivity.EGameActivitySubType sub_activity_type = 2;
  inline bool has_sub_activity_type() const;
  inline void clear_sub_activity_type();
  static const int kSubActivityTypeFieldNumber = 2;
  inline ::Msg::ReqAckJoinActivity_EGameActivitySubType sub_activity_type() const;
  inline void set_sub_activity_type(::Msg::ReqAckJoinActivity_EGameActivitySubType value);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckJoinActivity)
 private:
  inline void set_has_activity_type();
  inline void clear_has_activity_type();
  inline void set_has_sub_activity_type();
  inline void clear_has_sub_activity_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int activity_type_;
  int sub_activity_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckJoinActivity* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckCreateGuild : public ::google::protobuf::Message {
 public:
  ReqAckCreateGuild();
  virtual ~ReqAckCreateGuild();

  ReqAckCreateGuild(const ReqAckCreateGuild& from);

  inline ReqAckCreateGuild& operator=(const ReqAckCreateGuild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckCreateGuild& default_instance();

  void Swap(ReqAckCreateGuild* other);

  // implements Message ----------------------------------------------

  ReqAckCreateGuild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckCreateGuild& from);
  void MergeFrom(const ReqAckCreateGuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_id = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // required string guild_name = 2;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 2;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckCreateGuild)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();
  inline void set_has_guild_name();
  inline void clear_has_guild_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;
  ::std::string* guild_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckCreateGuild* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSearchGuild : public ::google::protobuf::Message {
 public:
  ReqSearchGuild();
  virtual ~ReqSearchGuild();

  ReqSearchGuild(const ReqSearchGuild& from);

  inline ReqSearchGuild& operator=(const ReqSearchGuild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSearchGuild& default_instance();

  void Swap(ReqSearchGuild* other);

  // implements Message ----------------------------------------------

  ReqSearchGuild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSearchGuild& from);
  void MergeFrom(const ReqSearchGuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string guild_name = 1;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 1;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // @@protoc_insertion_point(class_scope:Msg.ReqSearchGuild)
 private:
  inline void set_has_guild_name();
  inline void clear_has_guild_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guild_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSearchGuild* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckSearchGuild_SearchGuildObject : public ::google::protobuf::Message {
 public:
  AckSearchGuild_SearchGuildObject();
  virtual ~AckSearchGuild_SearchGuildObject();

  AckSearchGuild_SearchGuildObject(const AckSearchGuild_SearchGuildObject& from);

  inline AckSearchGuild_SearchGuildObject& operator=(const AckSearchGuild_SearchGuildObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSearchGuild_SearchGuildObject& default_instance();

  void Swap(AckSearchGuild_SearchGuildObject* other);

  // implements Message ----------------------------------------------

  AckSearchGuild_SearchGuildObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSearchGuild_SearchGuildObject& from);
  void MergeFrom(const AckSearchGuild_SearchGuildObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_ID = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIDFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // required string guild_name = 2;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 2;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // required string guild_icon = 3;
  inline bool has_guild_icon() const;
  inline void clear_guild_icon();
  static const int kGuildIconFieldNumber = 3;
  inline const ::std::string& guild_icon() const;
  inline void set_guild_icon(const ::std::string& value);
  inline void set_guild_icon(const char* value);
  inline void set_guild_icon(const char* value, size_t size);
  inline ::std::string* mutable_guild_icon();
  inline ::std::string* release_guild_icon();
  inline void set_allocated_guild_icon(::std::string* guild_icon);

  // required int32 guild_member_count = 4;
  inline bool has_guild_member_count() const;
  inline void clear_guild_member_count();
  static const int kGuildMemberCountFieldNumber = 4;
  inline ::google::protobuf::int32 guild_member_count() const;
  inline void set_guild_member_count(::google::protobuf::int32 value);

  // required int32 guild_member_max_count = 5;
  inline bool has_guild_member_max_count() const;
  inline void clear_guild_member_max_count();
  static const int kGuildMemberMaxCountFieldNumber = 5;
  inline ::google::protobuf::int32 guild_member_max_count() const;
  inline void set_guild_member_max_count(::google::protobuf::int32 value);

  // required int32 guild_honor = 6;
  inline bool has_guild_honor() const;
  inline void clear_guild_honor();
  static const int kGuildHonorFieldNumber = 6;
  inline ::google::protobuf::int32 guild_honor() const;
  inline void set_guild_honor(::google::protobuf::int32 value);

  // required int32 guild_rank = 7;
  inline bool has_guild_rank() const;
  inline void clear_guild_rank();
  static const int kGuildRankFieldNumber = 7;
  inline ::google::protobuf::int32 guild_rank() const;
  inline void set_guild_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckSearchGuild.SearchGuildObject)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();
  inline void set_has_guild_name();
  inline void clear_has_guild_name();
  inline void set_has_guild_icon();
  inline void clear_has_guild_icon();
  inline void set_has_guild_member_count();
  inline void clear_has_guild_member_count();
  inline void set_has_guild_member_max_count();
  inline void clear_has_guild_member_max_count();
  inline void set_has_guild_honor();
  inline void clear_has_guild_honor();
  inline void set_has_guild_rank();
  inline void clear_has_guild_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;
  ::std::string* guild_name_;
  ::std::string* guild_icon_;
  ::google::protobuf::int32 guild_member_count_;
  ::google::protobuf::int32 guild_member_max_count_;
  ::google::protobuf::int32 guild_honor_;
  ::google::protobuf::int32 guild_rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckSearchGuild_SearchGuildObject* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckSearchGuild : public ::google::protobuf::Message {
 public:
  AckSearchGuild();
  virtual ~AckSearchGuild();

  AckSearchGuild(const AckSearchGuild& from);

  inline AckSearchGuild& operator=(const AckSearchGuild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSearchGuild& default_instance();

  void Swap(AckSearchGuild* other);

  // implements Message ----------------------------------------------

  AckSearchGuild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSearchGuild& from);
  void MergeFrom(const AckSearchGuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AckSearchGuild_SearchGuildObject SearchGuildObject;

  // accessors -------------------------------------------------------

  // repeated .Msg.AckSearchGuild.SearchGuildObject guild_list = 1;
  inline int guild_list_size() const;
  inline void clear_guild_list();
  static const int kGuildListFieldNumber = 1;
  inline const ::Msg::AckSearchGuild_SearchGuildObject& guild_list(int index) const;
  inline ::Msg::AckSearchGuild_SearchGuildObject* mutable_guild_list(int index);
  inline ::Msg::AckSearchGuild_SearchGuildObject* add_guild_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::AckSearchGuild_SearchGuildObject >&
      guild_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::AckSearchGuild_SearchGuildObject >*
      mutable_guild_list();

  // @@protoc_insertion_point(class_scope:Msg.AckSearchGuild)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::AckSearchGuild_SearchGuildObject > guild_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckSearchGuild* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckJoinGuild : public ::google::protobuf::Message {
 public:
  ReqAckJoinGuild();
  virtual ~ReqAckJoinGuild();

  ReqAckJoinGuild(const ReqAckJoinGuild& from);

  inline ReqAckJoinGuild& operator=(const ReqAckJoinGuild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckJoinGuild& default_instance();

  void Swap(ReqAckJoinGuild* other);

  // implements Message ----------------------------------------------

  ReqAckJoinGuild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckJoinGuild& from);
  void MergeFrom(const ReqAckJoinGuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_id = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // required string guild_name = 2;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 2;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckJoinGuild)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();
  inline void set_has_guild_name();
  inline void clear_has_guild_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;
  ::std::string* guild_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckJoinGuild* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckLeaveGuild : public ::google::protobuf::Message {
 public:
  ReqAckLeaveGuild();
  virtual ~ReqAckLeaveGuild();

  ReqAckLeaveGuild(const ReqAckLeaveGuild& from);

  inline ReqAckLeaveGuild& operator=(const ReqAckLeaveGuild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckLeaveGuild& default_instance();

  void Swap(ReqAckLeaveGuild* other);

  // implements Message ----------------------------------------------

  ReqAckLeaveGuild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckLeaveGuild& from);
  void MergeFrom(const ReqAckLeaveGuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_id = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // required string guild_name = 2;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 2;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckLeaveGuild)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();
  inline void set_has_guild_name();
  inline void clear_has_guild_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;
  ::std::string* guild_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckLeaveGuild* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckOprGuildMember : public ::google::protobuf::Message {
 public:
  ReqAckOprGuildMember();
  virtual ~ReqAckOprGuildMember();

  ReqAckOprGuildMember(const ReqAckOprGuildMember& from);

  inline ReqAckOprGuildMember& operator=(const ReqAckOprGuildMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckOprGuildMember& default_instance();

  void Swap(ReqAckOprGuildMember* other);

  // implements Message ----------------------------------------------

  ReqAckOprGuildMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckOprGuildMember& from);
  void MergeFrom(const ReqAckOprGuildMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckOprGuildMember_EGGuildMemberOprType EGGuildMemberOprType;
  static const EGGuildMemberOprType EGAT_DOWN = ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_DOWN;
  static const EGGuildMemberOprType EGAT_UP = ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_UP;
  static const EGGuildMemberOprType EGAT_KICK = ReqAckOprGuildMember_EGGuildMemberOprType_EGAT_KICK;
  static inline bool EGGuildMemberOprType_IsValid(int value) {
    return ReqAckOprGuildMember_EGGuildMemberOprType_IsValid(value);
  }
  static const EGGuildMemberOprType EGGuildMemberOprType_MIN =
    ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_MIN;
  static const EGGuildMemberOprType EGGuildMemberOprType_MAX =
    ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_MAX;
  static const int EGGuildMemberOprType_ARRAYSIZE =
    ReqAckOprGuildMember_EGGuildMemberOprType_EGGuildMemberOprType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGGuildMemberOprType_descriptor() {
    return ReqAckOprGuildMember_EGGuildMemberOprType_descriptor();
  }
  static inline const ::std::string& EGGuildMemberOprType_Name(EGGuildMemberOprType value) {
    return ReqAckOprGuildMember_EGGuildMemberOprType_Name(value);
  }
  static inline bool EGGuildMemberOprType_Parse(const ::std::string& name,
      EGGuildMemberOprType* value) {
    return ReqAckOprGuildMember_EGGuildMemberOprType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_id = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // required .Msg.Ident member_id = 2;
  inline bool has_member_id() const;
  inline void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  inline const ::Msg::Ident& member_id() const;
  inline ::Msg::Ident* mutable_member_id();
  inline ::Msg::Ident* release_member_id();
  inline void set_allocated_member_id(::Msg::Ident* member_id);

  // required .Msg.ReqAckOprGuildMember.EGGuildMemberOprType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::Msg::ReqAckOprGuildMember_EGGuildMemberOprType type() const;
  inline void set_type(::Msg::ReqAckOprGuildMember_EGGuildMemberOprType value);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckOprGuildMember)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();
  inline void set_has_member_id();
  inline void clear_has_member_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;
  ::Msg::Ident* member_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckOprGuildMember* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqEnterGuildEctype : public ::google::protobuf::Message {
 public:
  ReqEnterGuildEctype();
  virtual ~ReqEnterGuildEctype();

  ReqEnterGuildEctype(const ReqEnterGuildEctype& from);

  inline ReqEnterGuildEctype& operator=(const ReqEnterGuildEctype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEnterGuildEctype& default_instance();

  void Swap(ReqEnterGuildEctype* other);

  // implements Message ----------------------------------------------

  ReqEnterGuildEctype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEnterGuildEctype& from);
  void MergeFrom(const ReqEnterGuildEctype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident guild_id = 1;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 1;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqEnterGuildEctype)
 private:
  inline void set_has_guild_id();
  inline void clear_has_guild_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* guild_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqEnterGuildEctype* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqIntensifylevelToEquip : public ::google::protobuf::Message {
 public:
  ReqIntensifylevelToEquip();
  virtual ~ReqIntensifylevelToEquip();

  ReqIntensifylevelToEquip(const ReqIntensifylevelToEquip& from);

  inline ReqIntensifylevelToEquip& operator=(const ReqIntensifylevelToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqIntensifylevelToEquip& default_instance();

  void Swap(ReqIntensifylevelToEquip* other);

  // implements Message ----------------------------------------------

  ReqIntensifylevelToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqIntensifylevelToEquip& from);
  void MergeFrom(const ReqIntensifylevelToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // @@protoc_insertion_point(class_scope:Msg.ReqIntensifylevelToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqIntensifylevelToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckIntensifylevelToEquip : public ::google::protobuf::Message {
 public:
  AckIntensifylevelToEquip();
  virtual ~AckIntensifylevelToEquip();

  AckIntensifylevelToEquip(const AckIntensifylevelToEquip& from);

  inline AckIntensifylevelToEquip& operator=(const AckIntensifylevelToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckIntensifylevelToEquip& default_instance();

  void Swap(AckIntensifylevelToEquip* other);

  // implements Message ----------------------------------------------

  AckIntensifylevelToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckIntensifylevelToEquip& from);
  void MergeFrom(const AckIntensifylevelToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckIntensifylevelToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckIntensifylevelToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqHoleToEquip : public ::google::protobuf::Message {
 public:
  ReqHoleToEquip();
  virtual ~ReqHoleToEquip();

  ReqHoleToEquip(const ReqHoleToEquip& from);

  inline ReqHoleToEquip& operator=(const ReqHoleToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHoleToEquip& default_instance();

  void Swap(ReqHoleToEquip* other);

  // implements Message ----------------------------------------------

  ReqHoleToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHoleToEquip& from);
  void MergeFrom(const ReqHoleToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // @@protoc_insertion_point(class_scope:Msg.ReqHoleToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqHoleToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckHoleToEquip : public ::google::protobuf::Message {
 public:
  AckHoleToEquip();
  virtual ~AckHoleToEquip();

  AckHoleToEquip(const AckHoleToEquip& from);

  inline AckHoleToEquip& operator=(const AckHoleToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHoleToEquip& default_instance();

  void Swap(AckHoleToEquip* other);

  // implements Message ----------------------------------------------

  AckHoleToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHoleToEquip& from);
  void MergeFrom(const AckHoleToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckHoleToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckHoleToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqInlaystoneToEquip : public ::google::protobuf::Message {
 public:
  ReqInlaystoneToEquip();
  virtual ~ReqInlaystoneToEquip();

  ReqInlaystoneToEquip(const ReqInlaystoneToEquip& from);

  inline ReqInlaystoneToEquip& operator=(const ReqInlaystoneToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqInlaystoneToEquip& default_instance();

  void Swap(ReqInlaystoneToEquip* other);

  // implements Message ----------------------------------------------

  ReqInlaystoneToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqInlaystoneToEquip& from);
  void MergeFrom(const ReqInlaystoneToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required bytes stoneid = 2;
  inline bool has_stoneid() const;
  inline void clear_stoneid();
  static const int kStoneidFieldNumber = 2;
  inline const ::std::string& stoneid() const;
  inline void set_stoneid(const ::std::string& value);
  inline void set_stoneid(const char* value);
  inline void set_stoneid(const void* value, size_t size);
  inline ::std::string* mutable_stoneid();
  inline ::std::string* release_stoneid();
  inline void set_allocated_stoneid(::std::string* stoneid);

  // required int32 hole_index = 3;
  inline bool has_hole_index() const;
  inline void clear_hole_index();
  static const int kHoleIndexFieldNumber = 3;
  inline ::google::protobuf::int32 hole_index() const;
  inline void set_hole_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqInlaystoneToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_stoneid();
  inline void clear_has_stoneid();
  inline void set_has_hole_index();
  inline void clear_has_hole_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::std::string* stoneid_;
  ::google::protobuf::int32 hole_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqInlaystoneToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckInlaystoneToEquip : public ::google::protobuf::Message {
 public:
  AckInlaystoneToEquip();
  virtual ~AckInlaystoneToEquip();

  AckInlaystoneToEquip(const AckInlaystoneToEquip& from);

  inline AckInlaystoneToEquip& operator=(const AckInlaystoneToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckInlaystoneToEquip& default_instance();

  void Swap(AckInlaystoneToEquip* other);

  // implements Message ----------------------------------------------

  AckInlaystoneToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckInlaystoneToEquip& from);
  void MergeFrom(const AckInlaystoneToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckInlaystoneToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckInlaystoneToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqElementlevelToEquip : public ::google::protobuf::Message {
 public:
  ReqElementlevelToEquip();
  virtual ~ReqElementlevelToEquip();

  ReqElementlevelToEquip(const ReqElementlevelToEquip& from);

  inline ReqElementlevelToEquip& operator=(const ReqElementlevelToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqElementlevelToEquip& default_instance();

  void Swap(ReqElementlevelToEquip* other);

  // implements Message ----------------------------------------------

  ReqElementlevelToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqElementlevelToEquip& from);
  void MergeFrom(const ReqElementlevelToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required .Msg.EGameElementType eElementType = 2;
  inline bool has_eelementtype() const;
  inline void clear_eelementtype();
  static const int kEElementTypeFieldNumber = 2;
  inline ::Msg::EGameElementType eelementtype() const;
  inline void set_eelementtype(::Msg::EGameElementType value);

  // @@protoc_insertion_point(class_scope:Msg.ReqElementlevelToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_eelementtype();
  inline void clear_has_eelementtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  int eelementtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqElementlevelToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckElementlevelToEquip : public ::google::protobuf::Message {
 public:
  AckElementlevelToEquip();
  virtual ~AckElementlevelToEquip();

  AckElementlevelToEquip(const AckElementlevelToEquip& from);

  inline AckElementlevelToEquip& operator=(const AckElementlevelToEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckElementlevelToEquip& default_instance();

  void Swap(AckElementlevelToEquip* other);

  // implements Message ----------------------------------------------

  AckElementlevelToEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckElementlevelToEquip& from);
  void MergeFrom(const AckElementlevelToEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident equipid = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipidFieldNumber = 1;
  inline const ::Msg::Ident& equipid() const;
  inline ::Msg::Ident* mutable_equipid();
  inline ::Msg::Ident* release_equipid();
  inline void set_allocated_equipid(::Msg::Ident* equipid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckElementlevelToEquip)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* equipid_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckElementlevelToEquip* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSetFightHero : public ::google::protobuf::Message {
 public:
  ReqSetFightHero();
  virtual ~ReqSetFightHero();

  ReqSetFightHero(const ReqSetFightHero& from);

  inline ReqSetFightHero& operator=(const ReqSetFightHero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSetFightHero& default_instance();

  void Swap(ReqSetFightHero* other);

  // implements Message ----------------------------------------------

  ReqSetFightHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSetFightHero& from);
  void MergeFrom(const ReqSetFightHero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident Heroid = 1;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroidFieldNumber = 1;
  inline const ::Msg::Ident& heroid() const;
  inline ::Msg::Ident* mutable_heroid();
  inline ::Msg::Ident* release_heroid();
  inline void set_allocated_heroid(::Msg::Ident* heroid);

  // required int32 Set = 2;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 2;
  inline ::google::protobuf::int32 set() const;
  inline void set_set(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqSetFightHero)
 private:
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_set();
  inline void clear_has_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* heroid_;
  ::google::protobuf::int32 set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSetFightHero* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSwitchFightHero : public ::google::protobuf::Message {
 public:
  ReqSwitchFightHero();
  virtual ~ReqSwitchFightHero();

  ReqSwitchFightHero(const ReqSwitchFightHero& from);

  inline ReqSwitchFightHero& operator=(const ReqSwitchFightHero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSwitchFightHero& default_instance();

  void Swap(ReqSwitchFightHero* other);

  // implements Message ----------------------------------------------

  ReqSwitchFightHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSwitchFightHero& from);
  void MergeFrom(const ReqSwitchFightHero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident Heroid = 1;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroidFieldNumber = 1;
  inline const ::Msg::Ident& heroid() const;
  inline ::Msg::Ident* mutable_heroid();
  inline ::Msg::Ident* release_heroid();
  inline void set_allocated_heroid(::Msg::Ident* heroid);

  // @@protoc_insertion_point(class_scope:Msg.ReqSwitchFightHero)
 private:
  inline void set_has_heroid();
  inline void clear_has_heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSwitchFightHero* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMiningTitle : public ::google::protobuf::Message {
 public:
  ReqMiningTitle();
  virtual ~ReqMiningTitle();

  ReqMiningTitle(const ReqMiningTitle& from);

  inline ReqMiningTitle& operator=(const ReqMiningTitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMiningTitle& default_instance();

  void Swap(ReqMiningTitle* other);

  // implements Message ----------------------------------------------

  ReqMiningTitle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMiningTitle& from);
  void MergeFrom(const ReqMiningTitle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 opr = 3;
  inline bool has_opr() const;
  inline void clear_opr();
  static const int kOprFieldNumber = 3;
  inline ::google::protobuf::int32 opr() const;
  inline void set_opr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqMiningTitle)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_opr();
  inline void clear_has_opr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 opr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqMiningTitle* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TileState : public ::google::protobuf::Message {
 public:
  TileState();
  virtual ~TileState();

  TileState(const TileState& from);

  inline TileState& operator=(const TileState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileState& default_instance();

  void Swap(TileState* other);

  // implements Message ----------------------------------------------

  TileState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileState& from);
  void MergeFrom(const TileState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 opr = 3;
  inline bool has_opr() const;
  inline void clear_opr();
  static const int kOprFieldNumber = 3;
  inline ::google::protobuf::int32 opr() const;
  inline void set_opr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.TileState)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_opr();
  inline void clear_has_opr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 opr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TileState* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TileBuilding : public ::google::protobuf::Message {
 public:
  TileBuilding();
  virtual ~TileBuilding();

  TileBuilding(const TileBuilding& from);

  inline TileBuilding& operator=(const TileBuilding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileBuilding& default_instance();

  void Swap(TileBuilding* other);

  // implements Message ----------------------------------------------

  TileBuilding* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileBuilding& from);
  void MergeFrom(const TileBuilding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required string coigID = 3;
  inline bool has_coigid() const;
  inline void clear_coigid();
  static const int kCoigIDFieldNumber = 3;
  inline const ::std::string& coigid() const;
  inline void set_coigid(const ::std::string& value);
  inline void set_coigid(const char* value);
  inline void set_coigid(const char* value, size_t size);
  inline ::std::string* mutable_coigid();
  inline ::std::string* release_coigid();
  inline void set_allocated_coigid(::std::string* coigid);

  // required .Msg.Ident guid = 4;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 4;
  inline const ::Msg::Ident& guid() const;
  inline ::Msg::Ident* mutable_guid();
  inline ::Msg::Ident* release_guid();
  inline void set_allocated_guid(::Msg::Ident* guid);

  // @@protoc_insertion_point(class_scope:Msg.TileBuilding)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_coigid();
  inline void clear_has_coigid();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::std::string* coigid_;
  ::Msg::Ident* guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TileBuilding* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TileNPC : public ::google::protobuf::Message {
 public:
  TileNPC();
  virtual ~TileNPC();

  TileNPC(const TileNPC& from);

  inline TileNPC& operator=(const TileNPC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileNPC& default_instance();

  void Swap(TileNPC* other);

  // implements Message ----------------------------------------------

  TileNPC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileNPC& from);
  void MergeFrom(const TileNPC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required string coigID = 3;
  inline bool has_coigid() const;
  inline void clear_coigid();
  static const int kCoigIDFieldNumber = 3;
  inline const ::std::string& coigid() const;
  inline void set_coigid(const ::std::string& value);
  inline void set_coigid(const char* value);
  inline void set_coigid(const char* value, size_t size);
  inline ::std::string* mutable_coigid();
  inline ::std::string* release_coigid();
  inline void set_allocated_coigid(::std::string* coigid);

  // required .Msg.Ident guid = 4;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 4;
  inline const ::Msg::Ident& guid() const;
  inline ::Msg::Ident* mutable_guid();
  inline ::Msg::Ident* release_guid();
  inline void set_allocated_guid(::Msg::Ident* guid);

  // @@protoc_insertion_point(class_scope:Msg.TileNPC)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_coigid();
  inline void clear_has_coigid();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::std::string* coigid_;
  ::Msg::Ident* guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TileNPC* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMiningTitle : public ::google::protobuf::Message {
 public:
  AckMiningTitle();
  virtual ~AckMiningTitle();

  AckMiningTitle(const AckMiningTitle& from);

  inline AckMiningTitle& operator=(const AckMiningTitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMiningTitle& default_instance();

  void Swap(AckMiningTitle* other);

  // implements Message ----------------------------------------------

  AckMiningTitle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckMiningTitle& from);
  void MergeFrom(const AckMiningTitle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Msg.TileState tile = 1;
  inline int tile_size() const;
  inline void clear_tile();
  static const int kTileFieldNumber = 1;
  inline const ::Msg::TileState& tile(int index) const;
  inline ::Msg::TileState* mutable_tile(int index);
  inline ::Msg::TileState* add_tile();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileState >&
      tile() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::TileState >*
      mutable_tile();

  // repeated .Msg.TileBuilding building = 2;
  inline int building_size() const;
  inline void clear_building();
  static const int kBuildingFieldNumber = 2;
  inline const ::Msg::TileBuilding& building(int index) const;
  inline ::Msg::TileBuilding* mutable_building(int index);
  inline ::Msg::TileBuilding* add_building();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileBuilding >&
      building() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::TileBuilding >*
      mutable_building();

  // repeated .Msg.TileNPC npc = 3;
  inline int npc_size() const;
  inline void clear_npc();
  static const int kNpcFieldNumber = 3;
  inline const ::Msg::TileNPC& npc(int index) const;
  inline ::Msg::TileNPC* mutable_npc(int index);
  inline ::Msg::TileNPC* add_npc();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileNPC >&
      npc() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::TileNPC >*
      mutable_npc();

  // @@protoc_insertion_point(class_scope:Msg.AckMiningTitle)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::TileState > tile_;
  ::google::protobuf::RepeatedPtrField< ::Msg::TileBuilding > building_;
  ::google::protobuf::RepeatedPtrField< ::Msg::TileNPC > npc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckMiningTitle* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSearchOppnent : public ::google::protobuf::Message {
 public:
  ReqSearchOppnent();
  virtual ~ReqSearchOppnent();

  ReqSearchOppnent(const ReqSearchOppnent& from);

  inline ReqSearchOppnent& operator=(const ReqSearchOppnent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSearchOppnent& default_instance();

  void Swap(ReqSearchOppnent* other);

  // implements Message ----------------------------------------------

  ReqSearchOppnent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSearchOppnent& from);
  void MergeFrom(const ReqSearchOppnent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqSearchOppnent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSearchOppnent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckSearchOppnent : public ::google::protobuf::Message {
 public:
  AckSearchOppnent();
  virtual ~AckSearchOppnent();

  AckSearchOppnent(const AckSearchOppnent& from);

  inline AckSearchOppnent& operator=(const AckSearchOppnent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSearchOppnent& default_instance();

  void Swap(AckSearchOppnent* other);

  // implements Message ----------------------------------------------

  AckSearchOppnent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSearchOppnent& from);
  void MergeFrom(const AckSearchOppnent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 scene_id = 1;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 1;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckSearchOppnent)
 private:
  inline void set_has_scene_id();
  inline void clear_has_scene_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 scene_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckSearchOppnent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSendMail : public ::google::protobuf::Message {
 public:
  ReqSendMail();
  virtual ~ReqSendMail();

  ReqSendMail(const ReqSendMail& from);

  inline ReqSendMail& operator=(const ReqSendMail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSendMail& default_instance();

  void Swap(ReqSendMail* other);

  // implements Message ----------------------------------------------

  ReqSendMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSendMail& from);
  void MergeFrom(const ReqSendMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident reciever = 1;
  inline bool has_reciever() const;
  inline void clear_reciever();
  static const int kRecieverFieldNumber = 1;
  inline const ::Msg::Ident& reciever() const;
  inline ::Msg::Ident* mutable_reciever();
  inline ::Msg::Ident* release_reciever();
  inline void set_allocated_reciever(::Msg::Ident* reciever);

  // repeated .Msg.ItemStruct item_list = 2;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 2;
  inline const ::Msg::ItemStruct& item_list(int index) const;
  inline ::Msg::ItemStruct* mutable_item_list(int index);
  inline ::Msg::ItemStruct* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >*
      mutable_item_list();

  // repeated .Msg.CurrencyStruct currency_list = 3;
  inline int currency_list_size() const;
  inline void clear_currency_list();
  static const int kCurrencyListFieldNumber = 3;
  inline const ::Msg::CurrencyStruct& currency_list(int index) const;
  inline ::Msg::CurrencyStruct* mutable_currency_list(int index);
  inline ::Msg::CurrencyStruct* add_currency_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::CurrencyStruct >&
      currency_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::CurrencyStruct >*
      mutable_currency_list();

  // @@protoc_insertion_point(class_scope:Msg.ReqSendMail)
 private:
  inline void set_has_reciever();
  inline void clear_has_reciever();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* reciever_;
  ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct > item_list_;
  ::google::protobuf::RepeatedPtrField< ::Msg::CurrencyStruct > currency_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSendMail* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqSwitchServer : public ::google::protobuf::Message {
 public:
  ReqSwitchServer();
  virtual ~ReqSwitchServer();

  ReqSwitchServer(const ReqSwitchServer& from);

  inline ReqSwitchServer& operator=(const ReqSwitchServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSwitchServer& default_instance();

  void Swap(ReqSwitchServer* other);

  // implements Message ----------------------------------------------

  ReqSwitchServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSwitchServer& from);
  void MergeFrom(const ReqSwitchServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident selfid = 1;
  inline bool has_selfid() const;
  inline void clear_selfid();
  static const int kSelfidFieldNumber = 1;
  inline const ::Msg::Ident& selfid() const;
  inline ::Msg::Ident* mutable_selfid();
  inline ::Msg::Ident* release_selfid();
  inline void set_allocated_selfid(::Msg::Ident* selfid);

  // required int64 self_serverid = 2;
  inline bool has_self_serverid() const;
  inline void clear_self_serverid();
  static const int kSelfServeridFieldNumber = 2;
  inline ::google::protobuf::int64 self_serverid() const;
  inline void set_self_serverid(::google::protobuf::int64 value);

  // required int64 target_serverid = 3;
  inline bool has_target_serverid() const;
  inline void clear_target_serverid();
  static const int kTargetServeridFieldNumber = 3;
  inline ::google::protobuf::int64 target_serverid() const;
  inline void set_target_serverid(::google::protobuf::int64 value);

  // required int64 gate_serverid = 4;
  inline bool has_gate_serverid() const;
  inline void clear_gate_serverid();
  static const int kGateServeridFieldNumber = 4;
  inline ::google::protobuf::int64 gate_serverid() const;
  inline void set_gate_serverid(::google::protobuf::int64 value);

  // required int64 SceneID = 5;
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIDFieldNumber = 5;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // required .Msg.Ident client_id = 6;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 6;
  inline const ::Msg::Ident& client_id() const;
  inline ::Msg::Ident* mutable_client_id();
  inline ::Msg::Ident* release_client_id();
  inline void set_allocated_client_id(::Msg::Ident* client_id);

  // required int64 groupID = 7;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 7;
  inline ::google::protobuf::int64 groupid() const;
  inline void set_groupid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqSwitchServer)
 private:
  inline void set_has_selfid();
  inline void clear_has_selfid();
  inline void set_has_self_serverid();
  inline void clear_has_self_serverid();
  inline void set_has_target_serverid();
  inline void clear_has_target_serverid();
  inline void set_has_gate_serverid();
  inline void clear_has_gate_serverid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* selfid_;
  ::google::protobuf::int64 self_serverid_;
  ::google::protobuf::int64 target_serverid_;
  ::google::protobuf::int64 gate_serverid_;
  ::google::protobuf::int64 sceneid_;
  ::Msg::Ident* client_id_;
  ::google::protobuf::int64 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqSwitchServer* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckSwitchServer : public ::google::protobuf::Message {
 public:
  AckSwitchServer();
  virtual ~AckSwitchServer();

  AckSwitchServer(const AckSwitchServer& from);

  inline AckSwitchServer& operator=(const AckSwitchServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSwitchServer& default_instance();

  void Swap(AckSwitchServer* other);

  // implements Message ----------------------------------------------

  AckSwitchServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSwitchServer& from);
  void MergeFrom(const AckSwitchServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident selfid = 1;
  inline bool has_selfid() const;
  inline void clear_selfid();
  static const int kSelfidFieldNumber = 1;
  inline const ::Msg::Ident& selfid() const;
  inline ::Msg::Ident* mutable_selfid();
  inline ::Msg::Ident* release_selfid();
  inline void set_allocated_selfid(::Msg::Ident* selfid);

  // required int64 self_serverid = 2;
  inline bool has_self_serverid() const;
  inline void clear_self_serverid();
  static const int kSelfServeridFieldNumber = 2;
  inline ::google::protobuf::int64 self_serverid() const;
  inline void set_self_serverid(::google::protobuf::int64 value);

  // required int64 target_serverid = 3;
  inline bool has_target_serverid() const;
  inline void clear_target_serverid();
  static const int kTargetServeridFieldNumber = 3;
  inline ::google::protobuf::int64 target_serverid() const;
  inline void set_target_serverid(::google::protobuf::int64 value);

  // required int64 gate_serverid = 4;
  inline bool has_gate_serverid() const;
  inline void clear_gate_serverid();
  static const int kGateServeridFieldNumber = 4;
  inline ::google::protobuf::int64 gate_serverid() const;
  inline void set_gate_serverid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Msg.AckSwitchServer)
 private:
  inline void set_has_selfid();
  inline void clear_has_selfid();
  inline void set_has_self_serverid();
  inline void clear_has_self_serverid();
  inline void set_has_target_serverid();
  inline void clear_has_target_serverid();
  inline void set_has_gate_serverid();
  inline void clear_has_gate_serverid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* selfid_;
  ::google::protobuf::int64 self_serverid_;
  ::google::protobuf::int64 target_serverid_;
  ::google::protobuf::int64 gate_serverid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckSwitchServer* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TeamIo : public ::google::protobuf::Message {
 public:
  TeamIo();
  virtual ~TeamIo();

  TeamIo(const TeamIo& from);

  inline TeamIo& operator=(const TeamIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamIo& default_instance();

  void Swap(TeamIo* other);

  // implements Message ----------------------------------------------

  TeamIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamIo& from);
  void MergeFrom(const TeamIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // required .Msg.Ident captain_id = 2;
  inline bool has_captain_id() const;
  inline void clear_captain_id();
  static const int kCaptainIdFieldNumber = 2;
  inline const ::Msg::Ident& captain_id() const;
  inline ::Msg::Ident* mutable_captain_id();
  inline ::Msg::Ident* release_captain_id();
  inline void set_allocated_captain_id(::Msg::Ident* captain_id);

  // repeated .Msg.TeammemberIo teammemberIo = 3;
  inline int teammemberio_size() const;
  inline void clear_teammemberio();
  static const int kTeammemberIoFieldNumber = 3;
  inline const ::Msg::TeammemberIo& teammemberio(int index) const;
  inline ::Msg::TeammemberIo* mutable_teammemberio(int index);
  inline ::Msg::TeammemberIo* add_teammemberio();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::TeammemberIo >&
      teammemberio() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::TeammemberIo >*
      mutable_teammemberio();

  // @@protoc_insertion_point(class_scope:Msg.TeamIo)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_captain_id();
  inline void clear_has_captain_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::Ident* captain_id_;
  ::google::protobuf::RepeatedPtrField< ::Msg::TeammemberIo > teammemberio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TeamIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TeammemberIo : public ::google::protobuf::Message {
 public:
  TeammemberIo();
  virtual ~TeammemberIo();

  TeammemberIo(const TeammemberIo& from);

  inline TeammemberIo& operator=(const TeammemberIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeammemberIo& default_instance();

  void Swap(TeammemberIo* other);

  // implements Message ----------------------------------------------

  TeammemberIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeammemberIo& from);
  void MergeFrom(const TeammemberIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::Msg::Ident& player_id() const;
  inline ::Msg::Ident* mutable_player_id();
  inline ::Msg::Ident* release_player_id();
  inline void set_allocated_player_id(::Msg::Ident* player_id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 nLevel = 3;
  inline bool has_nlevel() const;
  inline void clear_nlevel();
  static const int kNLevelFieldNumber = 3;
  inline ::google::protobuf::int32 nlevel() const;
  inline void set_nlevel(::google::protobuf::int32 value);

  // required int32 job = 4;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 4;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // required string HeadIcon = 5;
  inline bool has_headicon() const;
  inline void clear_headicon();
  static const int kHeadIconFieldNumber = 5;
  inline const ::std::string& headicon() const;
  inline void set_headicon(const ::std::string& value);
  inline void set_headicon(const char* value);
  inline void set_headicon(const char* value, size_t size);
  inline ::std::string* mutable_headicon();
  inline ::std::string* release_headicon();
  inline void set_allocated_headicon(::std::string* headicon);

  // @@protoc_insertion_point(class_scope:Msg.TeammemberIo)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nlevel();
  inline void clear_has_nlevel();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_headicon();
  inline void clear_has_headicon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* player_id_;
  ::std::string* name_;
  ::google::protobuf::int32 nlevel_;
  ::google::protobuf::int32 job_;
  ::std::string* headicon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static TeammemberIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckCreateTeam : public ::google::protobuf::Message {
 public:
  ReqAckCreateTeam();
  virtual ~ReqAckCreateTeam();

  ReqAckCreateTeam(const ReqAckCreateTeam& from);

  inline ReqAckCreateTeam& operator=(const ReqAckCreateTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckCreateTeam& default_instance();

  void Swap(ReqAckCreateTeam* other);

  // implements Message ----------------------------------------------

  ReqAckCreateTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckCreateTeam& from);
  void MergeFrom(const ReqAckCreateTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // optional .Msg.TeamIo xTeamIo = 2;
  inline bool has_xteamio() const;
  inline void clear_xteamio();
  static const int kXTeamIoFieldNumber = 2;
  inline const ::Msg::TeamIo& xteamio() const;
  inline ::Msg::TeamIo* mutable_xteamio();
  inline ::Msg::TeamIo* release_xteamio();
  inline void set_allocated_xteamio(::Msg::TeamIo* xteamio);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckCreateTeam)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_xteamio();
  inline void clear_has_xteamio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::TeamIo* xteamio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckCreateTeam* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckJoinTeam : public ::google::protobuf::Message {
 public:
  ReqAckJoinTeam();
  virtual ~ReqAckJoinTeam();

  ReqAckJoinTeam(const ReqAckJoinTeam& from);

  inline ReqAckJoinTeam& operator=(const ReqAckJoinTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckJoinTeam& default_instance();

  void Swap(ReqAckJoinTeam* other);

  // implements Message ----------------------------------------------

  ReqAckJoinTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckJoinTeam& from);
  void MergeFrom(const ReqAckJoinTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // optional .Msg.TeamIo xTeamIo = 2;
  inline bool has_xteamio() const;
  inline void clear_xteamio();
  static const int kXTeamIoFieldNumber = 2;
  inline const ::Msg::TeamIo& xteamio() const;
  inline ::Msg::TeamIo* mutable_xteamio();
  inline ::Msg::TeamIo* release_xteamio();
  inline void set_allocated_xteamio(::Msg::TeamIo* xteamio);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckJoinTeam)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_xteamio();
  inline void clear_has_xteamio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::TeamIo* xteamio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckJoinTeam* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckLeaveTeam : public ::google::protobuf::Message {
 public:
  ReqAckLeaveTeam();
  virtual ~ReqAckLeaveTeam();

  ReqAckLeaveTeam(const ReqAckLeaveTeam& from);

  inline ReqAckLeaveTeam& operator=(const ReqAckLeaveTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckLeaveTeam& default_instance();

  void Swap(ReqAckLeaveTeam* other);

  // implements Message ----------------------------------------------

  ReqAckLeaveTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckLeaveTeam& from);
  void MergeFrom(const ReqAckLeaveTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // optional .Msg.TeamIo xTeamIo = 2;
  inline bool has_xteamio() const;
  inline void clear_xteamio();
  static const int kXTeamIoFieldNumber = 2;
  inline const ::Msg::TeamIo& xteamio() const;
  inline ::Msg::TeamIo* mutable_xteamio();
  inline ::Msg::TeamIo* release_xteamio();
  inline void set_allocated_xteamio(::Msg::TeamIo* xteamio);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckLeaveTeam)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_xteamio();
  inline void clear_has_xteamio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::TeamIo* xteamio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckLeaveTeam* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckOprTeamMember : public ::google::protobuf::Message {
 public:
  ReqAckOprTeamMember();
  virtual ~ReqAckOprTeamMember();

  ReqAckOprTeamMember(const ReqAckOprTeamMember& from);

  inline ReqAckOprTeamMember& operator=(const ReqAckOprTeamMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckOprTeamMember& default_instance();

  void Swap(ReqAckOprTeamMember* other);

  // implements Message ----------------------------------------------

  ReqAckOprTeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckOprTeamMember& from);
  void MergeFrom(const ReqAckOprTeamMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqAckOprTeamMember_EGTeamMemberOprType EGTeamMemberOprType;
  static const EGTeamMemberOprType EGAT_DOWN = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN;
  static const EGTeamMemberOprType EGAT_UP = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_UP;
  static const EGTeamMemberOprType EGAT_KICK = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICK;
  static const EGTeamMemberOprType EGAT_APPOINT = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_APPOINT;
  static const EGTeamMemberOprType EGAT_FIRE = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_FIRE;
  static const EGTeamMemberOprType EGAT_DEMISE = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DEMISE;
  static const EGTeamMemberOprType EGAT_ACCEPTAPPLY = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_ACCEPTAPPLY;
  static const EGTeamMemberOprType EGAT_DENYAPPLY = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DENYAPPLY;
  static const EGTeamMemberOprType EGAT_KICKOUT = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT;
  static inline bool EGTeamMemberOprType_IsValid(int value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_IsValid(value);
  }
  static const EGTeamMemberOprType EGTeamMemberOprType_MIN =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MIN;
  static const EGTeamMemberOprType EGTeamMemberOprType_MAX =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX;
  static const int EGTeamMemberOprType_ARRAYSIZE =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGTeamMemberOprType_descriptor() {
    return ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
  }
  static inline const ::std::string& EGTeamMemberOprType_Name(EGTeamMemberOprType value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_Name(value);
  }
  static inline bool EGTeamMemberOprType_Parse(const ::std::string& name,
      EGTeamMemberOprType* value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // required .Msg.Ident member_id = 2;
  inline bool has_member_id() const;
  inline void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  inline const ::Msg::Ident& member_id() const;
  inline ::Msg::Ident* mutable_member_id();
  inline ::Msg::Ident* release_member_id();
  inline void set_allocated_member_id(::Msg::Ident* member_id);

  // required .Msg.ReqAckOprTeamMember.EGTeamMemberOprType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::Msg::ReqAckOprTeamMember_EGTeamMemberOprType type() const;
  inline void set_type(::Msg::ReqAckOprTeamMember_EGTeamMemberOprType value);

  // optional .Msg.TeamIo xTeamIo = 4;
  inline bool has_xteamio() const;
  inline void clear_xteamio();
  static const int kXTeamIoFieldNumber = 4;
  inline const ::Msg::TeamIo& xteamio() const;
  inline ::Msg::TeamIo* mutable_xteamio();
  inline ::Msg::TeamIo* release_xteamio();
  inline void set_allocated_xteamio(::Msg::TeamIo* xteamio);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckOprTeamMember)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_member_id();
  inline void clear_has_member_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_xteamio();
  inline void clear_has_xteamio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::Ident* member_id_;
  ::Msg::TeamIo* xteamio_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckOprTeamMember* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckInviteTeam : public ::google::protobuf::Message {
 public:
  ReqAckInviteTeam();
  virtual ~ReqAckInviteTeam();

  ReqAckInviteTeam(const ReqAckInviteTeam& from);

  inline ReqAckInviteTeam& operator=(const ReqAckInviteTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckInviteTeam& default_instance();

  void Swap(ReqAckInviteTeam* other);

  // implements Message ----------------------------------------------

  ReqAckInviteTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAckInviteTeam& from);
  void MergeFrom(const ReqAckInviteTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // required .Msg.Ident self_id = 2;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // required .Msg.Ident invite_target_id = 3;
  inline bool has_invite_target_id() const;
  inline void clear_invite_target_id();
  static const int kInviteTargetIdFieldNumber = 3;
  inline const ::Msg::Ident& invite_target_id() const;
  inline ::Msg::Ident* mutable_invite_target_id();
  inline ::Msg::Ident* release_invite_target_id();
  inline void set_allocated_invite_target_id(::Msg::Ident* invite_target_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqAckInviteTeam)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_invite_target_id();
  inline void clear_has_invite_target_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::Ident* self_id_;
  ::Msg::Ident* invite_target_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqAckInviteTeam* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqTeamEnterEctype : public ::google::protobuf::Message {
 public:
  ReqTeamEnterEctype();
  virtual ~ReqTeamEnterEctype();

  ReqTeamEnterEctype(const ReqTeamEnterEctype& from);

  inline ReqTeamEnterEctype& operator=(const ReqTeamEnterEctype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTeamEnterEctype& default_instance();

  void Swap(ReqTeamEnterEctype* other);

  // implements Message ----------------------------------------------

  ReqTeamEnterEctype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqTeamEnterEctype& from);
  void MergeFrom(const ReqTeamEnterEctype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // required .Msg.Ident self_id = 2;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // optional int32 nEctypeID = 3;
  inline bool has_nectypeid() const;
  inline void clear_nectypeid();
  static const int kNEctypeIDFieldNumber = 3;
  inline ::google::protobuf::int32 nectypeid() const;
  inline void set_nectypeid(::google::protobuf::int32 value);

  // optional int32 nGroupID = 4;
  inline bool has_ngroupid() const;
  inline void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 4;
  inline ::google::protobuf::int32 ngroupid() const;
  inline void set_ngroupid(::google::protobuf::int32 value);

  // optional int32 nResult = 5;
  inline bool has_nresult() const;
  inline void clear_nresult();
  static const int kNResultFieldNumber = 5;
  inline ::google::protobuf::int32 nresult() const;
  inline void set_nresult(::google::protobuf::int32 value);

  // optional int32 nServerID = 6;
  inline bool has_nserverid() const;
  inline void clear_nserverid();
  static const int kNServerIDFieldNumber = 6;
  inline ::google::protobuf::int32 nserverid() const;
  inline void set_nserverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.ReqTeamEnterEctype)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_nectypeid();
  inline void clear_has_nectypeid();
  inline void set_has_ngroupid();
  inline void clear_has_ngroupid();
  inline void set_has_nresult();
  inline void clear_has_nresult();
  inline void set_has_nserverid();
  inline void clear_has_nserverid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::Ident* self_id_;
  ::google::protobuf::int32 nectypeid_;
  ::google::protobuf::int32 ngroupid_;
  ::google::protobuf::int32 nresult_;
  ::google::protobuf::int32 nserverid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqTeamEnterEctype* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckTeamEnterEctype : public ::google::protobuf::Message {
 public:
  AckTeamEnterEctype();
  virtual ~AckTeamEnterEctype();

  AckTeamEnterEctype(const AckTeamEnterEctype& from);

  inline AckTeamEnterEctype& operator=(const AckTeamEnterEctype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckTeamEnterEctype& default_instance();

  void Swap(AckTeamEnterEctype* other);

  // implements Message ----------------------------------------------

  AckTeamEnterEctype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckTeamEnterEctype& from);
  void MergeFrom(const AckTeamEnterEctype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // required .Msg.Ident self_id = 2;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // optional int32 nEctypeID = 3;
  inline bool has_nectypeid() const;
  inline void clear_nectypeid();
  static const int kNEctypeIDFieldNumber = 3;
  inline ::google::protobuf::int32 nectypeid() const;
  inline void set_nectypeid(::google::protobuf::int32 value);

  // optional int32 nGroupID = 4;
  inline bool has_ngroupid() const;
  inline void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 4;
  inline ::google::protobuf::int32 ngroupid() const;
  inline void set_ngroupid(::google::protobuf::int32 value);

  // optional int32 nResult = 5;
  inline bool has_nresult() const;
  inline void clear_nresult();
  static const int kNResultFieldNumber = 5;
  inline ::google::protobuf::int32 nresult() const;
  inline void set_nresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckTeamEnterEctype)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_nectypeid();
  inline void clear_has_nectypeid();
  inline void set_has_ngroupid();
  inline void clear_has_ngroupid();
  inline void set_has_nresult();
  inline void clear_has_nresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* team_id_;
  ::Msg::Ident* self_id_;
  ::google::protobuf::int32 nectypeid_;
  ::google::protobuf::int32 ngroupid_;
  ::google::protobuf::int32 nresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckTeamEnterEctype* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT GridGuildBaseIo : public ::google::protobuf::Message {
 public:
  GridGuildBaseIo();
  virtual ~GridGuildBaseIo();

  GridGuildBaseIo(const GridGuildBaseIo& from);

  inline GridGuildBaseIo& operator=(const GridGuildBaseIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GridGuildBaseIo& default_instance();

  void Swap(GridGuildBaseIo* other);

  // implements Message ----------------------------------------------

  GridGuildBaseIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GridGuildBaseIo& from);
  void MergeFrom(const GridGuildBaseIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Msg::Ident& id() const;
  inline ::Msg::Ident* mutable_id();
  inline ::Msg::Ident* release_id();
  inline void set_allocated_id(::Msg::Ident* id);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline ::google::protobuf::int32 resource() const;
  inline void set_resource(::google::protobuf::int32 value);

  // required bytes icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const void* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // @@protoc_insertion_point(class_scope:Msg.GridGuildBaseIo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_icon();
  inline void clear_has_icon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 count_;
  ::std::string* icon_;
  ::google::protobuf::int32 resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static GridGuildBaseIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapGridIo : public ::google::protobuf::Message {
 public:
  ReqBigMapGridIo();
  virtual ~ReqBigMapGridIo();

  ReqBigMapGridIo(const ReqBigMapGridIo& from);

  inline ReqBigMapGridIo& operator=(const ReqBigMapGridIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapGridIo& default_instance();

  void Swap(ReqBigMapGridIo* other);

  // implements Message ----------------------------------------------

  ReqBigMapGridIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBigMapGridIo& from);
  void MergeFrom(const ReqBigMapGridIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes map_title_id = 1;
  inline int map_title_id_size() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id(int index) const;
  inline ::std::string* mutable_map_title_id(int index);
  inline void set_map_title_id(int index, const ::std::string& value);
  inline void set_map_title_id(int index, const char* value);
  inline void set_map_title_id(int index, const void* value, size_t size);
  inline ::std::string* add_map_title_id();
  inline void add_map_title_id(const ::std::string& value);
  inline void add_map_title_id(const char* value);
  inline void add_map_title_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& map_title_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_map_title_id();

  // @@protoc_insertion_point(class_scope:Msg.ReqBigMapGridIo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> map_title_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqBigMapGridIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridBaseIo : public ::google::protobuf::Message {
 public:
  BigMapGridBaseIo();
  virtual ~BigMapGridBaseIo();

  BigMapGridBaseIo(const BigMapGridBaseIo& from);

  inline BigMapGridBaseIo& operator=(const BigMapGridBaseIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridBaseIo& default_instance();

  void Swap(BigMapGridBaseIo* other);

  // implements Message ----------------------------------------------

  BigMapGridBaseIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigMapGridBaseIo& from);
  void MergeFrom(const BigMapGridBaseIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Msg.GridGuildBaseIo guild_io = 2;
  inline bool has_guild_io() const;
  inline void clear_guild_io();
  static const int kGuildIoFieldNumber = 2;
  inline const ::Msg::GridGuildBaseIo& guild_io() const;
  inline ::Msg::GridGuildBaseIo* mutable_guild_io();
  inline ::Msg::GridGuildBaseIo* release_guild_io();
  inline void set_allocated_guild_io(::Msg::GridGuildBaseIo* guild_io);

  // required int32 kingwar_time = 10;
  inline bool has_kingwar_time() const;
  inline void clear_kingwar_time();
  static const int kKingwarTimeFieldNumber = 10;
  inline ::google::protobuf::int32 kingwar_time() const;
  inline void set_kingwar_time(::google::protobuf::int32 value);

  // required .Msg.Ident kingwarrer = 11;
  inline bool has_kingwarrer() const;
  inline void clear_kingwarrer();
  static const int kKingwarrerFieldNumber = 11;
  inline const ::Msg::Ident& kingwarrer() const;
  inline ::Msg::Ident* mutable_kingwarrer();
  inline ::Msg::Ident* release_kingwarrer();
  inline void set_allocated_kingwarrer(::Msg::Ident* kingwarrer);

  // required int32 hurting_time = 20;
  inline bool has_hurting_time() const;
  inline void clear_hurting_time();
  static const int kHurtingTimeFieldNumber = 20;
  inline ::google::protobuf::int32 hurting_time() const;
  inline void set_hurting_time(::google::protobuf::int32 value);

  // required .Msg.Ident hurter = 21;
  inline bool has_hurter() const;
  inline void clear_hurter();
  static const int kHurterFieldNumber = 21;
  inline const ::Msg::Ident& hurter() const;
  inline ::Msg::Ident* mutable_hurter();
  inline ::Msg::Ident* release_hurter();
  inline void set_allocated_hurter(::Msg::Ident* hurter);

  // @@protoc_insertion_point(class_scope:Msg.BigMapGridBaseIo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_guild_io();
  inline void clear_has_guild_io();
  inline void set_has_kingwar_time();
  inline void clear_has_kingwar_time();
  inline void set_has_kingwarrer();
  inline void clear_has_kingwarrer();
  inline void set_has_hurting_time();
  inline void clear_has_hurting_time();
  inline void set_has_hurter();
  inline void clear_has_hurter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Msg::GridGuildBaseIo* guild_io_;
  ::Msg::Ident* kingwarrer_;
  ::google::protobuf::int32 kingwar_time_;
  ::google::protobuf::int32 hurting_time_;
  ::Msg::Ident* hurter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static BigMapGridBaseIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapLeaveMsg : public ::google::protobuf::Message {
 public:
  BigMapLeaveMsg();
  virtual ~BigMapLeaveMsg();

  BigMapLeaveMsg(const BigMapLeaveMsg& from);

  inline BigMapLeaveMsg& operator=(const BigMapLeaveMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapLeaveMsg& default_instance();

  void Swap(BigMapLeaveMsg* other);

  // implements Message ----------------------------------------------

  BigMapLeaveMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigMapLeaveMsg& from);
  void MergeFrom(const BigMapLeaveMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline const ::Msg::Ident& owner() const;
  inline ::Msg::Ident* mutable_owner();
  inline ::Msg::Ident* release_owner();
  inline void set_allocated_owner(::Msg::Ident* owner);

  // required bytes owner_name = 2;
  inline bool has_owner_name() const;
  inline void clear_owner_name();
  static const int kOwnerNameFieldNumber = 2;
  inline const ::std::string& owner_name() const;
  inline void set_owner_name(const ::std::string& value);
  inline void set_owner_name(const char* value);
  inline void set_owner_name(const void* value, size_t size);
  inline ::std::string* mutable_owner_name();
  inline ::std::string* release_owner_name();
  inline void set_allocated_owner_name(::std::string* owner_name);

  // required bytes msg_data = 3;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // required int32 msg_time = 4;
  inline bool has_msg_time() const;
  inline void clear_msg_time();
  static const int kMsgTimeFieldNumber = 4;
  inline ::google::protobuf::int32 msg_time() const;
  inline void set_msg_time(::google::protobuf::int32 value);

  // required int32 owner_level = 5;
  inline bool has_owner_level() const;
  inline void clear_owner_level();
  static const int kOwnerLevelFieldNumber = 5;
  inline ::google::protobuf::int32 owner_level() const;
  inline void set_owner_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.BigMapLeaveMsg)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_owner_name();
  inline void clear_has_owner_name();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_msg_time();
  inline void clear_has_msg_time();
  inline void set_has_owner_level();
  inline void clear_has_owner_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* owner_;
  ::std::string* owner_name_;
  ::std::string* msg_data_;
  ::google::protobuf::int32 msg_time_;
  ::google::protobuf::int32 owner_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static BigMapLeaveMsg* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapWarHistory : public ::google::protobuf::Message {
 public:
  BigMapWarHistory();
  virtual ~BigMapWarHistory();

  BigMapWarHistory(const BigMapWarHistory& from);

  inline BigMapWarHistory& operator=(const BigMapWarHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapWarHistory& default_instance();

  void Swap(BigMapWarHistory* other);

  // implements Message ----------------------------------------------

  BigMapWarHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigMapWarHistory& from);
  void MergeFrom(const BigMapWarHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.GridGuildBaseIo red_io = 1;
  inline bool has_red_io() const;
  inline void clear_red_io();
  static const int kRedIoFieldNumber = 1;
  inline const ::Msg::GridGuildBaseIo& red_io() const;
  inline ::Msg::GridGuildBaseIo* mutable_red_io();
  inline ::Msg::GridGuildBaseIo* release_red_io();
  inline void set_allocated_red_io(::Msg::GridGuildBaseIo* red_io);

  // required .Msg.GridGuildBaseIo blue_io = 2;
  inline bool has_blue_io() const;
  inline void clear_blue_io();
  static const int kBlueIoFieldNumber = 2;
  inline const ::Msg::GridGuildBaseIo& blue_io() const;
  inline ::Msg::GridGuildBaseIo* mutable_blue_io();
  inline ::Msg::GridGuildBaseIo* release_blue_io();
  inline void set_allocated_blue_io(::Msg::GridGuildBaseIo* blue_io);

  // required .Msg.Ident winner_id = 10;
  inline bool has_winner_id() const;
  inline void clear_winner_id();
  static const int kWinnerIdFieldNumber = 10;
  inline const ::Msg::Ident& winner_id() const;
  inline ::Msg::Ident* mutable_winner_id();
  inline ::Msg::Ident* release_winner_id();
  inline void set_allocated_winner_id(::Msg::Ident* winner_id);

  // required int32 war_time = 11;
  inline bool has_war_time() const;
  inline void clear_war_time();
  static const int kWarTimeFieldNumber = 11;
  inline ::google::protobuf::int32 war_time() const;
  inline void set_war_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.BigMapWarHistory)
 private:
  inline void set_has_red_io();
  inline void clear_has_red_io();
  inline void set_has_blue_io();
  inline void clear_has_blue_io();
  inline void set_has_winner_id();
  inline void clear_has_winner_id();
  inline void set_has_war_time();
  inline void clear_has_war_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::GridGuildBaseIo* red_io_;
  ::Msg::GridGuildBaseIo* blue_io_;
  ::Msg::Ident* winner_id_;
  ::google::protobuf::int32 war_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static BigMapWarHistory* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridDetailIo : public ::google::protobuf::Message {
 public:
  BigMapGridDetailIo();
  virtual ~BigMapGridDetailIo();

  BigMapGridDetailIo(const BigMapGridDetailIo& from);

  inline BigMapGridDetailIo& operator=(const BigMapGridDetailIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridDetailIo& default_instance();

  void Swap(BigMapGridDetailIo* other);

  // implements Message ----------------------------------------------

  BigMapGridDetailIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigMapGridDetailIo& from);
  void MergeFrom(const BigMapGridDetailIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.BigMapGridBaseIo grid_base_io = 1;
  inline bool has_grid_base_io() const;
  inline void clear_grid_base_io();
  static const int kGridBaseIoFieldNumber = 1;
  inline const ::Msg::BigMapGridBaseIo& grid_base_io() const;
  inline ::Msg::BigMapGridBaseIo* mutable_grid_base_io();
  inline ::Msg::BigMapGridBaseIo* release_grid_base_io();
  inline void set_allocated_grid_base_io(::Msg::BigMapGridBaseIo* grid_base_io);

  // repeated .Msg.GridGuildBaseIo stay_guid_list = 2;
  inline int stay_guid_list_size() const;
  inline void clear_stay_guid_list();
  static const int kStayGuidListFieldNumber = 2;
  inline const ::Msg::GridGuildBaseIo& stay_guid_list(int index) const;
  inline ::Msg::GridGuildBaseIo* mutable_stay_guid_list(int index);
  inline ::Msg::GridGuildBaseIo* add_stay_guid_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::GridGuildBaseIo >&
      stay_guid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::GridGuildBaseIo >*
      mutable_stay_guid_list();

  // repeated .Msg.BigMapLeaveMsg leave_msg = 3;
  inline int leave_msg_size() const;
  inline void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 3;
  inline const ::Msg::BigMapLeaveMsg& leave_msg(int index) const;
  inline ::Msg::BigMapLeaveMsg* mutable_leave_msg(int index);
  inline ::Msg::BigMapLeaveMsg* add_leave_msg();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapLeaveMsg >&
      leave_msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapLeaveMsg >*
      mutable_leave_msg();

  // repeated .Msg.BigMapWarHistory war_history = 4;
  inline int war_history_size() const;
  inline void clear_war_history();
  static const int kWarHistoryFieldNumber = 4;
  inline const ::Msg::BigMapWarHistory& war_history(int index) const;
  inline ::Msg::BigMapWarHistory* mutable_war_history(int index);
  inline ::Msg::BigMapWarHistory* add_war_history();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapWarHistory >&
      war_history() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapWarHistory >*
      mutable_war_history();

  // @@protoc_insertion_point(class_scope:Msg.BigMapGridDetailIo)
 private:
  inline void set_has_grid_base_io();
  inline void clear_has_grid_base_io();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::BigMapGridBaseIo* grid_base_io_;
  ::google::protobuf::RepeatedPtrField< ::Msg::GridGuildBaseIo > stay_guid_list_;
  ::google::protobuf::RepeatedPtrField< ::Msg::BigMapLeaveMsg > leave_msg_;
  ::google::protobuf::RepeatedPtrField< ::Msg::BigMapWarHistory > war_history_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static BigMapGridDetailIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapGridIo : public ::google::protobuf::Message {
 public:
  AckBigMapGridIo();
  virtual ~AckBigMapGridIo();

  AckBigMapGridIo(const AckBigMapGridIo& from);

  inline AckBigMapGridIo& operator=(const AckBigMapGridIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapGridIo& default_instance();

  void Swap(AckBigMapGridIo* other);

  // implements Message ----------------------------------------------

  AckBigMapGridIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckBigMapGridIo& from);
  void MergeFrom(const AckBigMapGridIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Msg.BigMapGridDetailIo map_data = 1;
  inline int map_data_size() const;
  inline void clear_map_data();
  static const int kMapDataFieldNumber = 1;
  inline const ::Msg::BigMapGridDetailIo& map_data(int index) const;
  inline ::Msg::BigMapGridDetailIo* mutable_map_data(int index);
  inline ::Msg::BigMapGridDetailIo* add_map_data();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridDetailIo >&
      map_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridDetailIo >*
      mutable_map_data();

  // @@protoc_insertion_point(class_scope:Msg.AckBigMapGridIo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridDetailIo > map_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckBigMapGridIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapIo : public ::google::protobuf::Message {
 public:
  ReqBigMapIo();
  virtual ~ReqBigMapIo();

  ReqBigMapIo(const ReqBigMapIo& from);

  inline ReqBigMapIo& operator=(const ReqBigMapIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapIo& default_instance();

  void Swap(ReqBigMapIo* other);

  // implements Message ----------------------------------------------

  ReqBigMapIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBigMapIo& from);
  void MergeFrom(const ReqBigMapIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.ReqBigMapIo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqBigMapIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapIo : public ::google::protobuf::Message {
 public:
  AckBigMapIo();
  virtual ~AckBigMapIo();

  AckBigMapIo(const AckBigMapIo& from);

  inline AckBigMapIo& operator=(const AckBigMapIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapIo& default_instance();

  void Swap(AckBigMapIo* other);

  // implements Message ----------------------------------------------

  AckBigMapIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckBigMapIo& from);
  void MergeFrom(const AckBigMapIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Msg.BigMapGridBaseIo grid_base_io = 1;
  inline int grid_base_io_size() const;
  inline void clear_grid_base_io();
  static const int kGridBaseIoFieldNumber = 1;
  inline const ::Msg::BigMapGridBaseIo& grid_base_io(int index) const;
  inline ::Msg::BigMapGridBaseIo* mutable_grid_base_io(int index);
  inline ::Msg::BigMapGridBaseIo* add_grid_base_io();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridBaseIo >&
      grid_base_io() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridBaseIo >*
      mutable_grid_base_io();

  // @@protoc_insertion_point(class_scope:Msg.AckBigMapIo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridBaseIo > grid_base_io_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckBigMapIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqHoldMapGrid : public ::google::protobuf::Message {
 public:
  ReqHoldMapGrid();
  virtual ~ReqHoldMapGrid();

  ReqHoldMapGrid(const ReqHoldMapGrid& from);

  inline ReqHoldMapGrid& operator=(const ReqHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHoldMapGrid& default_instance();

  void Swap(ReqHoldMapGrid* other);

  // implements Message ----------------------------------------------

  ReqHoldMapGrid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHoldMapGrid& from);
  void MergeFrom(const ReqHoldMapGrid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_title_id = 1;
  inline bool has_map_title_id() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id() const;
  inline void set_map_title_id(const ::std::string& value);
  inline void set_map_title_id(const char* value);
  inline void set_map_title_id(const void* value, size_t size);
  inline ::std::string* mutable_map_title_id();
  inline ::std::string* release_map_title_id();
  inline void set_allocated_map_title_id(::std::string* map_title_id);

  // required .Msg.Ident guild_id = 2;
  inline bool has_guild_id() const;
  inline void clear_guild_id();
  static const int kGuildIdFieldNumber = 2;
  inline const ::Msg::Ident& guild_id() const;
  inline ::Msg::Ident* mutable_guild_id();
  inline ::Msg::Ident* release_guild_id();
  inline void set_allocated_guild_id(::Msg::Ident* guild_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqHoldMapGrid)
 private:
  inline void set_has_map_title_id();
  inline void clear_has_map_title_id();
  inline void set_has_guild_id();
  inline void clear_has_guild_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_title_id_;
  ::Msg::Ident* guild_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqHoldMapGrid* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckHoldMapGrid : public ::google::protobuf::Message {
 public:
  AckHoldMapGrid();
  virtual ~AckHoldMapGrid();

  AckHoldMapGrid(const AckHoldMapGrid& from);

  inline AckHoldMapGrid& operator=(const AckHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHoldMapGrid& default_instance();

  void Swap(AckHoldMapGrid* other);

  // implements Message ----------------------------------------------

  AckHoldMapGrid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHoldMapGrid& from);
  void MergeFrom(const AckHoldMapGrid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.AckHoldMapGrid)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckHoldMapGrid* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqLeaveMapMsg : public ::google::protobuf::Message {
 public:
  ReqLeaveMapMsg();
  virtual ~ReqLeaveMapMsg();

  ReqLeaveMapMsg(const ReqLeaveMapMsg& from);

  inline ReqLeaveMapMsg& operator=(const ReqLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLeaveMapMsg& default_instance();

  void Swap(ReqLeaveMapMsg* other);

  // implements Message ----------------------------------------------

  ReqLeaveMapMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLeaveMapMsg& from);
  void MergeFrom(const ReqLeaveMapMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_title_id = 1;
  inline bool has_map_title_id() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id() const;
  inline void set_map_title_id(const ::std::string& value);
  inline void set_map_title_id(const char* value);
  inline void set_map_title_id(const void* value, size_t size);
  inline ::std::string* mutable_map_title_id();
  inline ::std::string* release_map_title_id();
  inline void set_allocated_map_title_id(::std::string* map_title_id);

  // required .Msg.BigMapLeaveMsg leave_msg = 2;
  inline bool has_leave_msg() const;
  inline void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 2;
  inline const ::Msg::BigMapLeaveMsg& leave_msg() const;
  inline ::Msg::BigMapLeaveMsg* mutable_leave_msg();
  inline ::Msg::BigMapLeaveMsg* release_leave_msg();
  inline void set_allocated_leave_msg(::Msg::BigMapLeaveMsg* leave_msg);

  // @@protoc_insertion_point(class_scope:Msg.ReqLeaveMapMsg)
 private:
  inline void set_has_map_title_id();
  inline void clear_has_map_title_id();
  inline void set_has_leave_msg();
  inline void clear_has_leave_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_title_id_;
  ::Msg::BigMapLeaveMsg* leave_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqLeaveMapMsg* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckLeaveMapMsg : public ::google::protobuf::Message {
 public:
  AckLeaveMapMsg();
  virtual ~AckLeaveMapMsg();

  AckLeaveMapMsg(const AckLeaveMapMsg& from);

  inline AckLeaveMapMsg& operator=(const AckLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLeaveMapMsg& default_instance();

  void Swap(AckLeaveMapMsg* other);

  // implements Message ----------------------------------------------

  AckLeaveMapMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLeaveMapMsg& from);
  void MergeFrom(const AckLeaveMapMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.AckLeaveMapMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckLeaveMapMsg* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqGetMapAward : public ::google::protobuf::Message {
 public:
  ReqGetMapAward();
  virtual ~ReqGetMapAward();

  ReqGetMapAward(const ReqGetMapAward& from);

  inline ReqGetMapAward& operator=(const ReqGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetMapAward& default_instance();

  void Swap(ReqGetMapAward* other);

  // implements Message ----------------------------------------------

  ReqGetMapAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetMapAward& from);
  void MergeFrom(const ReqGetMapAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_title_id = 1;
  inline bool has_map_title_id() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id() const;
  inline void set_map_title_id(const ::std::string& value);
  inline void set_map_title_id(const char* value);
  inline void set_map_title_id(const void* value, size_t size);
  inline ::std::string* mutable_map_title_id();
  inline ::std::string* release_map_title_id();
  inline void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqGetMapAward)
 private:
  inline void set_has_map_title_id();
  inline void clear_has_map_title_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_title_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqGetMapAward* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckGetMapAward : public ::google::protobuf::Message {
 public:
  AckGetMapAward();
  virtual ~AckGetMapAward();

  AckGetMapAward(const AckGetMapAward& from);

  inline AckGetMapAward& operator=(const AckGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGetMapAward& default_instance();

  void Swap(AckGetMapAward* other);

  // implements Message ----------------------------------------------

  AckGetMapAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGetMapAward& from);
  void MergeFrom(const AckGetMapAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.AckGetMapAward)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckGetMapAward* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapHunting : public ::google::protobuf::Message {
 public:
  ReqMapHunting();
  virtual ~ReqMapHunting();

  ReqMapHunting(const ReqMapHunting& from);

  inline ReqMapHunting& operator=(const ReqMapHunting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapHunting& default_instance();

  void Swap(ReqMapHunting* other);

  // implements Message ----------------------------------------------

  ReqMapHunting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMapHunting& from);
  void MergeFrom(const ReqMapHunting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_title_id = 1;
  inline bool has_map_title_id() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id() const;
  inline void set_map_title_id(const ::std::string& value);
  inline void set_map_title_id(const char* value);
  inline void set_map_title_id(const void* value, size_t size);
  inline ::std::string* mutable_map_title_id();
  inline ::std::string* release_map_title_id();
  inline void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqMapHunting)
 private:
  inline void set_has_map_title_id();
  inline void clear_has_map_title_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_title_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqMapHunting* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapHunting : public ::google::protobuf::Message {
 public:
  AckMapHunting();
  virtual ~AckMapHunting();

  AckMapHunting(const AckMapHunting& from);

  inline AckMapHunting& operator=(const AckMapHunting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapHunting& default_instance();

  void Swap(AckMapHunting* other);

  // implements Message ----------------------------------------------

  AckMapHunting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckMapHunting& from);
  void MergeFrom(const AckMapHunting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.AckMapHunting)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckMapHunting* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapKingWar : public ::google::protobuf::Message {
 public:
  ReqMapKingWar();
  virtual ~ReqMapKingWar();

  ReqMapKingWar(const ReqMapKingWar& from);

  inline ReqMapKingWar& operator=(const ReqMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapKingWar& default_instance();

  void Swap(ReqMapKingWar* other);

  // implements Message ----------------------------------------------

  ReqMapKingWar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMapKingWar& from);
  void MergeFrom(const ReqMapKingWar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_title_id = 1;
  inline bool has_map_title_id() const;
  inline void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  inline const ::std::string& map_title_id() const;
  inline void set_map_title_id(const ::std::string& value);
  inline void set_map_title_id(const char* value);
  inline void set_map_title_id(const void* value, size_t size);
  inline ::std::string* mutable_map_title_id();
  inline ::std::string* release_map_title_id();
  inline void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqMapKingWar)
 private:
  inline void set_has_map_title_id();
  inline void clear_has_map_title_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_title_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqMapKingWar* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapKingWar : public ::google::protobuf::Message {
 public:
  AckMapKingWar();
  virtual ~AckMapKingWar();

  AckMapKingWar(const AckMapKingWar& from);

  inline AckMapKingWar& operator=(const AckMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapKingWar& default_instance();

  void Swap(AckMapKingWar* other);

  // implements Message ----------------------------------------------

  AckMapKingWar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckMapKingWar& from);
  void MergeFrom(const AckMapKingWar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Msg.AckMapKingWar)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckMapKingWar* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PVPRoomIo : public ::google::protobuf::Message {
 public:
  PVPRoomIo();
  virtual ~PVPRoomIo();

  PVPRoomIo(const PVPRoomIo& from);

  inline PVPRoomIo& operator=(const PVPRoomIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PVPRoomIo& default_instance();

  void Swap(PVPRoomIo* other);

  // implements Message ----------------------------------------------

  PVPRoomIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PVPRoomIo& from);
  void MergeFrom(const PVPRoomIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nCellStatus = 1;
  inline bool has_ncellstatus() const;
  inline void clear_ncellstatus();
  static const int kNCellStatusFieldNumber = 1;
  inline ::google::protobuf::int32 ncellstatus() const;
  inline void set_ncellstatus(::google::protobuf::int32 value);

  // required .Msg.Ident RoomID = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 2;
  inline const ::Msg::Ident& roomid() const;
  inline ::Msg::Ident* mutable_roomid();
  inline ::Msg::Ident* release_roomid();
  inline void set_allocated_roomid(::Msg::Ident* roomid);

  // required int32 nPVPMode = 3;
  inline bool has_npvpmode() const;
  inline void clear_npvpmode();
  static const int kNPVPModeFieldNumber = 3;
  inline ::google::protobuf::int32 npvpmode() const;
  inline void set_npvpmode(::google::protobuf::int32 value);

  // required int32 nPVPGrade = 4;
  inline bool has_npvpgrade() const;
  inline void clear_npvpgrade();
  static const int kNPVPGradeFieldNumber = 4;
  inline ::google::protobuf::int32 npvpgrade() const;
  inline void set_npvpgrade(::google::protobuf::int32 value);

  // required int32 MaxPalyer = 5;
  inline bool has_maxpalyer() const;
  inline void clear_maxpalyer();
  static const int kMaxPalyerFieldNumber = 5;
  inline ::google::protobuf::int32 maxpalyer() const;
  inline void set_maxpalyer(::google::protobuf::int32 value);

  // repeated .Msg.Ident xRedPlayer = 6;
  inline int xredplayer_size() const;
  inline void clear_xredplayer();
  static const int kXRedPlayerFieldNumber = 6;
  inline const ::Msg::Ident& xredplayer(int index) const;
  inline ::Msg::Ident* mutable_xredplayer(int index);
  inline ::Msg::Ident* add_xredplayer();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
      xredplayer() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
      mutable_xredplayer();

  // repeated .Msg.Ident xBluePlayer = 7;
  inline int xblueplayer_size() const;
  inline void clear_xblueplayer();
  static const int kXBluePlayerFieldNumber = 7;
  inline const ::Msg::Ident& xblueplayer(int index) const;
  inline ::Msg::Ident* mutable_xblueplayer(int index);
  inline ::Msg::Ident* add_xblueplayer();
  inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
      xblueplayer() const;
  inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
      mutable_xblueplayer();

  // optional int64 serverid = 8;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 8;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // optional int64 SceneID = 9;
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIDFieldNumber = 9;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // optional int64 groupID = 10;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 10;
  inline ::google::protobuf::int64 groupid() const;
  inline void set_groupid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Msg.PVPRoomIo)
 private:
  inline void set_has_ncellstatus();
  inline void clear_has_ncellstatus();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_npvpmode();
  inline void clear_has_npvpmode();
  inline void set_has_npvpgrade();
  inline void clear_has_npvpgrade();
  inline void set_has_maxpalyer();
  inline void clear_has_maxpalyer();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* roomid_;
  ::google::protobuf::int32 ncellstatus_;
  ::google::protobuf::int32 npvpmode_;
  ::google::protobuf::int32 npvpgrade_;
  ::google::protobuf::int32 maxpalyer_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Ident > xredplayer_;
  ::google::protobuf::RepeatedPtrField< ::Msg::Ident > xblueplayer_;
  ::google::protobuf::int64 serverid_;
  ::google::protobuf::int64 sceneid_;
  ::google::protobuf::int64 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static PVPRoomIo* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqPVPApplyMatch : public ::google::protobuf::Message {
 public:
  ReqPVPApplyMatch();
  virtual ~ReqPVPApplyMatch();

  ReqPVPApplyMatch(const ReqPVPApplyMatch& from);

  inline ReqPVPApplyMatch& operator=(const ReqPVPApplyMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPVPApplyMatch& default_instance();

  void Swap(ReqPVPApplyMatch* other);

  // implements Message ----------------------------------------------

  ReqPVPApplyMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPVPApplyMatch& from);
  void MergeFrom(const ReqPVPApplyMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqPVPApplyMatch_EApplyType EApplyType;
  static const EApplyType EApplyType_Single = ReqPVPApplyMatch_EApplyType_EApplyType_Single;
  static const EApplyType EApplyType_Team = ReqPVPApplyMatch_EApplyType_EApplyType_Team;
  static inline bool EApplyType_IsValid(int value) {
    return ReqPVPApplyMatch_EApplyType_IsValid(value);
  }
  static const EApplyType EApplyType_MIN =
    ReqPVPApplyMatch_EApplyType_EApplyType_MIN;
  static const EApplyType EApplyType_MAX =
    ReqPVPApplyMatch_EApplyType_EApplyType_MAX;
  static const int EApplyType_ARRAYSIZE =
    ReqPVPApplyMatch_EApplyType_EApplyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EApplyType_descriptor() {
    return ReqPVPApplyMatch_EApplyType_descriptor();
  }
  static inline const ::std::string& EApplyType_Name(EApplyType value) {
    return ReqPVPApplyMatch_EApplyType_Name(value);
  }
  static inline bool EApplyType_Parse(const ::std::string& name,
      EApplyType* value) {
    return ReqPVPApplyMatch_EApplyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Msg.Ident self_id = 1;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 1;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // required int32 nPVPMode = 2;
  inline bool has_npvpmode() const;
  inline void clear_npvpmode();
  static const int kNPVPModeFieldNumber = 2;
  inline ::google::protobuf::int32 npvpmode() const;
  inline void set_npvpmode(::google::protobuf::int32 value);

  // optional int64 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int64 score() const;
  inline void set_score(::google::protobuf::int64 value);

  // required int32 ApplyType = 4;
  inline bool has_applytype() const;
  inline void clear_applytype();
  static const int kApplyTypeFieldNumber = 4;
  inline ::google::protobuf::int32 applytype() const;
  inline void set_applytype(::google::protobuf::int32 value);

  // optional .Msg.Ident team_id = 5;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 5;
  inline const ::Msg::Ident& team_id() const;
  inline ::Msg::Ident* mutable_team_id();
  inline ::Msg::Ident* release_team_id();
  inline void set_allocated_team_id(::Msg::Ident* team_id);

  // @@protoc_insertion_point(class_scope:Msg.ReqPVPApplyMatch)
 private:
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_npvpmode();
  inline void clear_has_npvpmode();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_applytype();
  inline void clear_has_applytype();
  inline void set_has_team_id();
  inline void clear_has_team_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* self_id_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int32 npvpmode_;
  ::google::protobuf::int32 applytype_;
  ::Msg::Ident* team_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqPVPApplyMatch* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckPVPApplyMatch : public ::google::protobuf::Message {
 public:
  AckPVPApplyMatch();
  virtual ~AckPVPApplyMatch();

  AckPVPApplyMatch(const AckPVPApplyMatch& from);

  inline AckPVPApplyMatch& operator=(const AckPVPApplyMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPVPApplyMatch& default_instance();

  void Swap(AckPVPApplyMatch* other);

  // implements Message ----------------------------------------------

  AckPVPApplyMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPVPApplyMatch& from);
  void MergeFrom(const AckPVPApplyMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident self_id = 1;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 1;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // optional .Msg.PVPRoomIo xRoomIo = 2;
  inline bool has_xroomio() const;
  inline void clear_xroomio();
  static const int kXRoomIoFieldNumber = 2;
  inline const ::Msg::PVPRoomIo& xroomio() const;
  inline ::Msg::PVPRoomIo* mutable_xroomio();
  inline ::Msg::PVPRoomIo* release_xroomio();
  inline void set_allocated_xroomio(::Msg::PVPRoomIo* xroomio);

  // required int32 ApplyType = 3;
  inline bool has_applytype() const;
  inline void clear_applytype();
  static const int kApplyTypeFieldNumber = 3;
  inline ::google::protobuf::int32 applytype() const;
  inline void set_applytype(::google::protobuf::int32 value);

  // required int32 nResult = 4;
  inline bool has_nresult() const;
  inline void clear_nresult();
  static const int kNResultFieldNumber = 4;
  inline ::google::protobuf::int32 nresult() const;
  inline void set_nresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckPVPApplyMatch)
 private:
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_xroomio();
  inline void clear_has_xroomio();
  inline void set_has_applytype();
  inline void clear_has_applytype();
  inline void set_has_nresult();
  inline void clear_has_nresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* self_id_;
  ::Msg::PVPRoomIo* xroomio_;
  ::google::protobuf::int32 applytype_;
  ::google::protobuf::int32 nresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckPVPApplyMatch* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqCreatePVPEctype : public ::google::protobuf::Message {
 public:
  ReqCreatePVPEctype();
  virtual ~ReqCreatePVPEctype();

  ReqCreatePVPEctype(const ReqCreatePVPEctype& from);

  inline ReqCreatePVPEctype& operator=(const ReqCreatePVPEctype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCreatePVPEctype& default_instance();

  void Swap(ReqCreatePVPEctype* other);

  // implements Message ----------------------------------------------

  ReqCreatePVPEctype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCreatePVPEctype& from);
  void MergeFrom(const ReqCreatePVPEctype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident self_id = 1;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 1;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // required .Msg.PVPRoomIo xRoomIo = 2;
  inline bool has_xroomio() const;
  inline void clear_xroomio();
  static const int kXRoomIoFieldNumber = 2;
  inline const ::Msg::PVPRoomIo& xroomio() const;
  inline ::Msg::PVPRoomIo* mutable_xroomio();
  inline ::Msg::PVPRoomIo* release_xroomio();
  inline void set_allocated_xroomio(::Msg::PVPRoomIo* xroomio);

  // @@protoc_insertion_point(class_scope:Msg.ReqCreatePVPEctype)
 private:
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_xroomio();
  inline void clear_has_xroomio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* self_id_;
  ::Msg::PVPRoomIo* xroomio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static ReqCreatePVPEctype* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckCreatePVPEctype : public ::google::protobuf::Message {
 public:
  AckCreatePVPEctype();
  virtual ~AckCreatePVPEctype();

  AckCreatePVPEctype(const AckCreatePVPEctype& from);

  inline AckCreatePVPEctype& operator=(const AckCreatePVPEctype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckCreatePVPEctype& default_instance();

  void Swap(AckCreatePVPEctype* other);

  // implements Message ----------------------------------------------

  AckCreatePVPEctype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckCreatePVPEctype& from);
  void MergeFrom(const AckCreatePVPEctype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Msg.Ident self_id = 1;
  inline bool has_self_id() const;
  inline void clear_self_id();
  static const int kSelfIdFieldNumber = 1;
  inline const ::Msg::Ident& self_id() const;
  inline ::Msg::Ident* mutable_self_id();
  inline ::Msg::Ident* release_self_id();
  inline void set_allocated_self_id(::Msg::Ident* self_id);

  // required .Msg.PVPRoomIo xRoomIo = 2;
  inline bool has_xroomio() const;
  inline void clear_xroomio();
  static const int kXRoomIoFieldNumber = 2;
  inline const ::Msg::PVPRoomIo& xroomio() const;
  inline ::Msg::PVPRoomIo* mutable_xroomio();
  inline ::Msg::PVPRoomIo* release_xroomio();
  inline void set_allocated_xroomio(::Msg::PVPRoomIo* xroomio);

  // required int32 ApplyType = 3;
  inline bool has_applytype() const;
  inline void clear_applytype();
  static const int kApplyTypeFieldNumber = 3;
  inline ::google::protobuf::int32 applytype() const;
  inline void set_applytype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Msg.AckCreatePVPEctype)
 private:
  inline void set_has_self_id();
  inline void clear_has_self_id();
  inline void set_has_xroomio();
  inline void clear_has_xroomio();
  inline void set_has_applytype();
  inline void clear_has_applytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Msg::Ident* self_id_;
  ::Msg::PVPRoomIo* xroomio_;
  ::google::protobuf::int32 applytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_MsgShare_2eproto();
  friend void protobuf_AssignDesc_MsgShare_2eproto();
  friend void protobuf_ShutdownFile_MsgShare_2eproto();

  void InitAsDefaultInstance();
  static AckCreatePVPEctype* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqEnterGameServer

// required .Msg.Ident id = 1;
inline bool ReqEnterGameServer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEnterGameServer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEnterGameServer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEnterGameServer::clear_id() {
  if (id_ != NULL) id_->::Msg::Ident::Clear();
  clear_has_id();
}
inline const ::Msg::Ident& ReqEnterGameServer::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Msg::Ident* ReqEnterGameServer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Msg::Ident;
  return id_;
}
inline ::Msg::Ident* ReqEnterGameServer::release_id() {
  clear_has_id();
  ::Msg::Ident* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ReqEnterGameServer::set_allocated_id(::Msg::Ident* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required bytes account = 2;
inline bool ReqEnterGameServer::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEnterGameServer::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEnterGameServer::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEnterGameServer::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ReqEnterGameServer::account() const {
  return *account_;
}
inline void ReqEnterGameServer::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqEnterGameServer::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqEnterGameServer::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqEnterGameServer::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ReqEnterGameServer::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqEnterGameServer::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 game_id = 3;
inline bool ReqEnterGameServer::has_game_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqEnterGameServer::set_has_game_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqEnterGameServer::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqEnterGameServer::clear_game_id() {
  game_id_ = 0;
  clear_has_game_id();
}
inline ::google::protobuf::int32 ReqEnterGameServer::game_id() const {
  return game_id_;
}
inline void ReqEnterGameServer::set_game_id(::google::protobuf::int32 value) {
  set_has_game_id();
  game_id_ = value;
}

// required bytes name = 4;
inline bool ReqEnterGameServer::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqEnterGameServer::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqEnterGameServer::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqEnterGameServer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ReqEnterGameServer::name() const {
  return *name_;
}
inline void ReqEnterGameServer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqEnterGameServer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqEnterGameServer::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqEnterGameServer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ReqEnterGameServer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqEnterGameServer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckEnterGameSuccess

// -------------------------------------------------------------------

// ReqHeartBeat

// -------------------------------------------------------------------

// ReqLeaveGameServer

// -------------------------------------------------------------------

// PlayerEntryIo

// required .Msg.Ident object_guid = 1;
inline bool PlayerEntryIo::has_object_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerEntryIo::set_has_object_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerEntryIo::clear_has_object_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerEntryIo::clear_object_guid() {
  if (object_guid_ != NULL) object_guid_->::Msg::Ident::Clear();
  clear_has_object_guid();
}
inline const ::Msg::Ident& PlayerEntryIo::object_guid() const {
  return object_guid_ != NULL ? *object_guid_ : *default_instance_->object_guid_;
}
inline ::Msg::Ident* PlayerEntryIo::mutable_object_guid() {
  set_has_object_guid();
  if (object_guid_ == NULL) object_guid_ = new ::Msg::Ident;
  return object_guid_;
}
inline ::Msg::Ident* PlayerEntryIo::release_object_guid() {
  clear_has_object_guid();
  ::Msg::Ident* temp = object_guid_;
  object_guid_ = NULL;
  return temp;
}
inline void PlayerEntryIo::set_allocated_object_guid(::Msg::Ident* object_guid) {
  delete object_guid_;
  object_guid_ = object_guid;
  if (object_guid) {
    set_has_object_guid();
  } else {
    clear_has_object_guid();
  }
}

// required float x = 2;
inline bool PlayerEntryIo::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerEntryIo::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerEntryIo::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerEntryIo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PlayerEntryIo::x() const {
  return x_;
}
inline void PlayerEntryIo::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool PlayerEntryIo::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerEntryIo::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerEntryIo::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerEntryIo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PlayerEntryIo::y() const {
  return y_;
}
inline void PlayerEntryIo::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 4;
inline bool PlayerEntryIo::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerEntryIo::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerEntryIo::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerEntryIo::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PlayerEntryIo::z() const {
  return z_;
}
inline void PlayerEntryIo::set_z(float value) {
  set_has_z();
  z_ = value;
}

// required int32 career_type = 5;
inline bool PlayerEntryIo::has_career_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerEntryIo::set_has_career_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerEntryIo::clear_has_career_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerEntryIo::clear_career_type() {
  career_type_ = 0;
  clear_has_career_type();
}
inline ::google::protobuf::int32 PlayerEntryIo::career_type() const {
  return career_type_;
}
inline void PlayerEntryIo::set_career_type(::google::protobuf::int32 value) {
  set_has_career_type();
  career_type_ = value;
}

// required int32 player_state = 6;
inline bool PlayerEntryIo::has_player_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerEntryIo::set_has_player_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerEntryIo::clear_has_player_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerEntryIo::clear_player_state() {
  player_state_ = 0;
  clear_has_player_state();
}
inline ::google::protobuf::int32 PlayerEntryIo::player_state() const {
  return player_state_;
}
inline void PlayerEntryIo::set_player_state(::google::protobuf::int32 value) {
  set_has_player_state();
  player_state_ = value;
}

// required bytes coig_id = 7;
inline bool PlayerEntryIo::has_coig_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerEntryIo::set_has_coig_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerEntryIo::clear_has_coig_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerEntryIo::clear_coig_id() {
  if (coig_id_ != &::google::protobuf::internal::kEmptyString) {
    coig_id_->clear();
  }
  clear_has_coig_id();
}
inline const ::std::string& PlayerEntryIo::coig_id() const {
  return *coig_id_;
}
inline void PlayerEntryIo::set_coig_id(const ::std::string& value) {
  set_has_coig_id();
  if (coig_id_ == &::google::protobuf::internal::kEmptyString) {
    coig_id_ = new ::std::string;
  }
  coig_id_->assign(value);
}
inline void PlayerEntryIo::set_coig_id(const char* value) {
  set_has_coig_id();
  if (coig_id_ == &::google::protobuf::internal::kEmptyString) {
    coig_id_ = new ::std::string;
  }
  coig_id_->assign(value);
}
inline void PlayerEntryIo::set_coig_id(const void* value, size_t size) {
  set_has_coig_id();
  if (coig_id_ == &::google::protobuf::internal::kEmptyString) {
    coig_id_ = new ::std::string;
  }
  coig_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerEntryIo::mutable_coig_id() {
  set_has_coig_id();
  if (coig_id_ == &::google::protobuf::internal::kEmptyString) {
    coig_id_ = new ::std::string;
  }
  return coig_id_;
}
inline ::std::string* PlayerEntryIo::release_coig_id() {
  clear_has_coig_id();
  if (coig_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coig_id_;
    coig_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerEntryIo::set_allocated_coig_id(::std::string* coig_id) {
  if (coig_id_ != &::google::protobuf::internal::kEmptyString) {
    delete coig_id_;
  }
  if (coig_id) {
    set_has_coig_id();
    coig_id_ = coig_id;
  } else {
    clear_has_coig_id();
    coig_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 scene_id = 8;
inline bool PlayerEntryIo::has_scene_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerEntryIo::set_has_scene_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerEntryIo::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerEntryIo::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 PlayerEntryIo::scene_id() const {
  return scene_id_;
}
inline void PlayerEntryIo::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// required bytes class_id = 9;
inline bool PlayerEntryIo::has_class_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerEntryIo::set_has_class_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerEntryIo::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerEntryIo::clear_class_id() {
  if (class_id_ != &::google::protobuf::internal::kEmptyString) {
    class_id_->clear();
  }
  clear_has_class_id();
}
inline const ::std::string& PlayerEntryIo::class_id() const {
  return *class_id_;
}
inline void PlayerEntryIo::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::kEmptyString) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void PlayerEntryIo::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::kEmptyString) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void PlayerEntryIo::set_class_id(const void* value, size_t size) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::kEmptyString) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerEntryIo::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::kEmptyString) {
    class_id_ = new ::std::string;
  }
  return class_id_;
}
inline ::std::string* PlayerEntryIo::release_class_id() {
  clear_has_class_id();
  if (class_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerEntryIo::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != &::google::protobuf::internal::kEmptyString) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckPlayerEntryList

// repeated .Msg.PlayerEntryIo object_list = 1;
inline int AckPlayerEntryList::object_list_size() const {
  return object_list_.size();
}
inline void AckPlayerEntryList::clear_object_list() {
  object_list_.Clear();
}
inline const ::Msg::PlayerEntryIo& AckPlayerEntryList::object_list(int index) const {
  return object_list_.Get(index);
}
inline ::Msg::PlayerEntryIo* AckPlayerEntryList::mutable_object_list(int index) {
  return object_list_.Mutable(index);
}
inline ::Msg::PlayerEntryIo* AckPlayerEntryList::add_object_list() {
  return object_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::PlayerEntryIo >&
AckPlayerEntryList::object_list() const {
  return object_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::PlayerEntryIo >*
AckPlayerEntryList::mutable_object_list() {
  return &object_list_;
}

// -------------------------------------------------------------------

// AckPlayerLeaveList

// repeated .Msg.Ident object_list = 1;
inline int AckPlayerLeaveList::object_list_size() const {
  return object_list_.size();
}
inline void AckPlayerLeaveList::clear_object_list() {
  object_list_.Clear();
}
inline const ::Msg::Ident& AckPlayerLeaveList::object_list(int index) const {
  return object_list_.Get(index);
}
inline ::Msg::Ident* AckPlayerLeaveList::mutable_object_list(int index) {
  return object_list_.Mutable(index);
}
inline ::Msg::Ident* AckPlayerLeaveList::add_object_list() {
  return object_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
AckPlayerLeaveList::object_list() const {
  return object_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
AckPlayerLeaveList::mutable_object_list() {
  return &object_list_;
}

// -------------------------------------------------------------------

// ReqAckSynData

// required .Msg.Ident syser = 1;
inline bool ReqAckSynData::has_syser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckSynData::set_has_syser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckSynData::clear_has_syser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckSynData::clear_syser() {
  if (syser_ != NULL) syser_->::Msg::Ident::Clear();
  clear_has_syser();
}
inline const ::Msg::Ident& ReqAckSynData::syser() const {
  return syser_ != NULL ? *syser_ : *default_instance_->syser_;
}
inline ::Msg::Ident* ReqAckSynData::mutable_syser() {
  set_has_syser();
  if (syser_ == NULL) syser_ = new ::Msg::Ident;
  return syser_;
}
inline ::Msg::Ident* ReqAckSynData::release_syser() {
  clear_has_syser();
  ::Msg::Ident* temp = syser_;
  syser_ = NULL;
  return temp;
}
inline void ReqAckSynData::set_allocated_syser(::Msg::Ident* syser) {
  delete syser_;
  syser_ = syser;
  if (syser) {
    set_has_syser();
  } else {
    clear_has_syser();
  }
}

// repeated .Msg.Ident object_list = 2;
inline int ReqAckSynData::object_list_size() const {
  return object_list_.size();
}
inline void ReqAckSynData::clear_object_list() {
  object_list_.Clear();
}
inline const ::Msg::Ident& ReqAckSynData::object_list(int index) const {
  return object_list_.Get(index);
}
inline ::Msg::Ident* ReqAckSynData::mutable_object_list(int index) {
  return object_list_.Mutable(index);
}
inline ::Msg::Ident* ReqAckSynData::add_object_list() {
  return object_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
ReqAckSynData::object_list() const {
  return object_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
ReqAckSynData::mutable_object_list() {
  return &object_list_;
}

// required bytes data = 3;
inline bool ReqAckSynData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckSynData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckSynData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckSynData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ReqAckSynData::data() const {
  return *data_;
}
inline void ReqAckSynData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckSynData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckSynData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckSynData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ReqAckSynData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckSynData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.ReqAckSynData.SynType syn_type = 4;
inline bool ReqAckSynData::has_syn_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckSynData::set_has_syn_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckSynData::clear_has_syn_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckSynData::clear_syn_type() {
  syn_type_ = 1;
  clear_has_syn_type();
}
inline ::Msg::ReqAckSynData_SynType ReqAckSynData::syn_type() const {
  return static_cast< ::Msg::ReqAckSynData_SynType >(syn_type_);
}
inline void ReqAckSynData::set_syn_type(::Msg::ReqAckSynData_SynType value) {
  assert(::Msg::ReqAckSynData_SynType_IsValid(value));
  set_has_syn_type();
  syn_type_ = value;
}

// required .Msg.ESynMsgID msg_id = 5;
inline bool ReqAckSynData::has_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqAckSynData::set_has_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqAckSynData::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqAckSynData::clear_msg_id() {
  msg_id_ = 0;
  clear_has_msg_id();
}
inline ::Msg::ESynMsgID ReqAckSynData::msg_id() const {
  return static_cast< ::Msg::ESynMsgID >(msg_id_);
}
inline void ReqAckSynData::set_msg_id(::Msg::ESynMsgID value) {
  assert(::Msg::ESynMsgID_IsValid(value));
  set_has_msg_id();
  msg_id_ = value;
}

// -------------------------------------------------------------------

// ReqAckPlayerMove

// required .Msg.Ident mover = 1;
inline bool ReqAckPlayerMove::has_mover() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckPlayerMove::set_has_mover() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckPlayerMove::clear_has_mover() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckPlayerMove::clear_mover() {
  if (mover_ != NULL) mover_->::Msg::Ident::Clear();
  clear_has_mover();
}
inline const ::Msg::Ident& ReqAckPlayerMove::mover() const {
  return mover_ != NULL ? *mover_ : *default_instance_->mover_;
}
inline ::Msg::Ident* ReqAckPlayerMove::mutable_mover() {
  set_has_mover();
  if (mover_ == NULL) mover_ = new ::Msg::Ident;
  return mover_;
}
inline ::Msg::Ident* ReqAckPlayerMove::release_mover() {
  clear_has_mover();
  ::Msg::Ident* temp = mover_;
  mover_ = NULL;
  return temp;
}
inline void ReqAckPlayerMove::set_allocated_mover(::Msg::Ident* mover) {
  delete mover_;
  mover_ = mover;
  if (mover) {
    set_has_mover();
  } else {
    clear_has_mover();
  }
}

// required int32 moveType = 2;
inline bool ReqAckPlayerMove::has_movetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckPlayerMove::set_has_movetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckPlayerMove::clear_has_movetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckPlayerMove::clear_movetype() {
  movetype_ = 0;
  clear_has_movetype();
}
inline ::google::protobuf::int32 ReqAckPlayerMove::movetype() const {
  return movetype_;
}
inline void ReqAckPlayerMove::set_movetype(::google::protobuf::int32 value) {
  set_has_movetype();
  movetype_ = value;
}

// required float speed = 3;
inline bool ReqAckPlayerMove::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckPlayerMove::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckPlayerMove::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckPlayerMove::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float ReqAckPlayerMove::speed() const {
  return speed_;
}
inline void ReqAckPlayerMove::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// required int32 time = 4;
inline bool ReqAckPlayerMove::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckPlayerMove::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckPlayerMove::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckPlayerMove::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 ReqAckPlayerMove::time() const {
  return time_;
}
inline void ReqAckPlayerMove::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// repeated .Msg.Vector3 target_pos = 5;
inline int ReqAckPlayerMove::target_pos_size() const {
  return target_pos_.size();
}
inline void ReqAckPlayerMove::clear_target_pos() {
  target_pos_.Clear();
}
inline const ::Msg::Vector3& ReqAckPlayerMove::target_pos(int index) const {
  return target_pos_.Get(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::mutable_target_pos(int index) {
  return target_pos_.Mutable(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::add_target_pos() {
  return target_pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
ReqAckPlayerMove::target_pos() const {
  return target_pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
ReqAckPlayerMove::mutable_target_pos() {
  return &target_pos_;
}

// repeated .Msg.Vector3 source_pos = 6;
inline int ReqAckPlayerMove::source_pos_size() const {
  return source_pos_.size();
}
inline void ReqAckPlayerMove::clear_source_pos() {
  source_pos_.Clear();
}
inline const ::Msg::Vector3& ReqAckPlayerMove::source_pos(int index) const {
  return source_pos_.Get(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::mutable_source_pos(int index) {
  return source_pos_.Mutable(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::add_source_pos() {
  return source_pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
ReqAckPlayerMove::source_pos() const {
  return source_pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
ReqAckPlayerMove::mutable_source_pos() {
  return &source_pos_;
}

// repeated .Msg.Vector3 move_direction = 7;
inline int ReqAckPlayerMove::move_direction_size() const {
  return move_direction_.size();
}
inline void ReqAckPlayerMove::clear_move_direction() {
  move_direction_.Clear();
}
inline const ::Msg::Vector3& ReqAckPlayerMove::move_direction(int index) const {
  return move_direction_.Get(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::mutable_move_direction(int index) {
  return move_direction_.Mutable(index);
}
inline ::Msg::Vector3* ReqAckPlayerMove::add_move_direction() {
  return move_direction_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >&
ReqAckPlayerMove::move_direction() const {
  return move_direction_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Vector3 >*
ReqAckPlayerMove::mutable_move_direction() {
  return &move_direction_;
}

// -------------------------------------------------------------------

// ReqAckPlayerChat_ChatContainer

// required int32 ConTainerType = 2;
inline bool ReqAckPlayerChat_ChatContainer::has_containertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckPlayerChat_ChatContainer::set_has_containertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckPlayerChat_ChatContainer::clear_has_containertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckPlayerChat_ChatContainer::clear_containertype() {
  containertype_ = 0;
  clear_has_containertype();
}
inline ::google::protobuf::int32 ReqAckPlayerChat_ChatContainer::containertype() const {
  return containertype_;
}
inline void ReqAckPlayerChat_ChatContainer::set_containertype(::google::protobuf::int32 value) {
  set_has_containertype();
  containertype_ = value;
}

// required bytes data_io = 3;
inline bool ReqAckPlayerChat_ChatContainer::has_data_io() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckPlayerChat_ChatContainer::set_has_data_io() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckPlayerChat_ChatContainer::clear_has_data_io() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckPlayerChat_ChatContainer::clear_data_io() {
  if (data_io_ != &::google::protobuf::internal::kEmptyString) {
    data_io_->clear();
  }
  clear_has_data_io();
}
inline const ::std::string& ReqAckPlayerChat_ChatContainer::data_io() const {
  return *data_io_;
}
inline void ReqAckPlayerChat_ChatContainer::set_data_io(const ::std::string& value) {
  set_has_data_io();
  if (data_io_ == &::google::protobuf::internal::kEmptyString) {
    data_io_ = new ::std::string;
  }
  data_io_->assign(value);
}
inline void ReqAckPlayerChat_ChatContainer::set_data_io(const char* value) {
  set_has_data_io();
  if (data_io_ == &::google::protobuf::internal::kEmptyString) {
    data_io_ = new ::std::string;
  }
  data_io_->assign(value);
}
inline void ReqAckPlayerChat_ChatContainer::set_data_io(const void* value, size_t size) {
  set_has_data_io();
  if (data_io_ == &::google::protobuf::internal::kEmptyString) {
    data_io_ = new ::std::string;
  }
  data_io_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckPlayerChat_ChatContainer::mutable_data_io() {
  set_has_data_io();
  if (data_io_ == &::google::protobuf::internal::kEmptyString) {
    data_io_ = new ::std::string;
  }
  return data_io_;
}
inline ::std::string* ReqAckPlayerChat_ChatContainer::release_data_io() {
  clear_has_data_io();
  if (data_io_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_io_;
    data_io_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckPlayerChat_ChatContainer::set_allocated_data_io(::std::string* data_io) {
  if (data_io_ != &::google::protobuf::internal::kEmptyString) {
    delete data_io_;
  }
  if (data_io) {
    set_has_data_io();
    data_io_ = data_io;
  } else {
    clear_has_data_io();
    data_io_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckPlayerChat

// required .Msg.Ident chat_id = 1;
inline bool ReqAckPlayerChat::has_chat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckPlayerChat::set_has_chat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckPlayerChat::clear_has_chat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckPlayerChat::clear_chat_id() {
  if (chat_id_ != NULL) chat_id_->::Msg::Ident::Clear();
  clear_has_chat_id();
}
inline const ::Msg::Ident& ReqAckPlayerChat::chat_id() const {
  return chat_id_ != NULL ? *chat_id_ : *default_instance_->chat_id_;
}
inline ::Msg::Ident* ReqAckPlayerChat::mutable_chat_id() {
  set_has_chat_id();
  if (chat_id_ == NULL) chat_id_ = new ::Msg::Ident;
  return chat_id_;
}
inline ::Msg::Ident* ReqAckPlayerChat::release_chat_id() {
  clear_has_chat_id();
  ::Msg::Ident* temp = chat_id_;
  chat_id_ = NULL;
  return temp;
}
inline void ReqAckPlayerChat::set_allocated_chat_id(::Msg::Ident* chat_id) {
  delete chat_id_;
  chat_id_ = chat_id;
  if (chat_id) {
    set_has_chat_id();
  } else {
    clear_has_chat_id();
  }
}

// required .Msg.ReqAckPlayerChat.EGameChatType chat_type = 2;
inline bool ReqAckPlayerChat::has_chat_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckPlayerChat::set_has_chat_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckPlayerChat::clear_has_chat_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckPlayerChat::clear_chat_type() {
  chat_type_ = 0;
  clear_has_chat_type();
}
inline ::Msg::ReqAckPlayerChat_EGameChatType ReqAckPlayerChat::chat_type() const {
  return static_cast< ::Msg::ReqAckPlayerChat_EGameChatType >(chat_type_);
}
inline void ReqAckPlayerChat::set_chat_type(::Msg::ReqAckPlayerChat_EGameChatType value) {
  assert(::Msg::ReqAckPlayerChat_EGameChatType_IsValid(value));
  set_has_chat_type();
  chat_type_ = value;
}

// required bytes chat_io = 3;
inline bool ReqAckPlayerChat::has_chat_io() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckPlayerChat::set_has_chat_io() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckPlayerChat::clear_has_chat_io() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckPlayerChat::clear_chat_io() {
  if (chat_io_ != &::google::protobuf::internal::kEmptyString) {
    chat_io_->clear();
  }
  clear_has_chat_io();
}
inline const ::std::string& ReqAckPlayerChat::chat_io() const {
  return *chat_io_;
}
inline void ReqAckPlayerChat::set_chat_io(const ::std::string& value) {
  set_has_chat_io();
  if (chat_io_ == &::google::protobuf::internal::kEmptyString) {
    chat_io_ = new ::std::string;
  }
  chat_io_->assign(value);
}
inline void ReqAckPlayerChat::set_chat_io(const char* value) {
  set_has_chat_io();
  if (chat_io_ == &::google::protobuf::internal::kEmptyString) {
    chat_io_ = new ::std::string;
  }
  chat_io_->assign(value);
}
inline void ReqAckPlayerChat::set_chat_io(const void* value, size_t size) {
  set_has_chat_io();
  if (chat_io_ == &::google::protobuf::internal::kEmptyString) {
    chat_io_ = new ::std::string;
  }
  chat_io_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckPlayerChat::mutable_chat_io() {
  set_has_chat_io();
  if (chat_io_ == &::google::protobuf::internal::kEmptyString) {
    chat_io_ = new ::std::string;
  }
  return chat_io_;
}
inline ::std::string* ReqAckPlayerChat::release_chat_io() {
  clear_has_chat_io();
  if (chat_io_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_io_;
    chat_io_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckPlayerChat::set_allocated_chat_io(::std::string* chat_io) {
  if (chat_io_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_io_;
  }
  if (chat_io) {
    set_has_chat_io();
    chat_io_ = chat_io;
  } else {
    clear_has_chat_io();
    chat_io_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes chat_name = 4;
inline bool ReqAckPlayerChat::has_chat_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckPlayerChat::set_has_chat_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckPlayerChat::clear_has_chat_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckPlayerChat::clear_chat_name() {
  if (chat_name_ != &::google::protobuf::internal::kEmptyString) {
    chat_name_->clear();
  }
  clear_has_chat_name();
}
inline const ::std::string& ReqAckPlayerChat::chat_name() const {
  return *chat_name_;
}
inline void ReqAckPlayerChat::set_chat_name(const ::std::string& value) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(value);
}
inline void ReqAckPlayerChat::set_chat_name(const char* value) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(value);
}
inline void ReqAckPlayerChat::set_chat_name(const void* value, size_t size) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckPlayerChat::mutable_chat_name() {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  return chat_name_;
}
inline ::std::string* ReqAckPlayerChat::release_chat_name() {
  clear_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_name_;
    chat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckPlayerChat::set_allocated_chat_name(::std::string* chat_name) {
  if (chat_name_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_name_;
  }
  if (chat_name) {
    set_has_chat_name();
    chat_name_ = chat_name;
  } else {
    clear_has_chat_name();
    chat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Msg.Ident target_id = 5;
inline bool ReqAckPlayerChat::has_target_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqAckPlayerChat::set_has_target_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqAckPlayerChat::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqAckPlayerChat::clear_target_id() {
  if (target_id_ != NULL) target_id_->::Msg::Ident::Clear();
  clear_has_target_id();
}
inline const ::Msg::Ident& ReqAckPlayerChat::target_id() const {
  return target_id_ != NULL ? *target_id_ : *default_instance_->target_id_;
}
inline ::Msg::Ident* ReqAckPlayerChat::mutable_target_id() {
  set_has_target_id();
  if (target_id_ == NULL) target_id_ = new ::Msg::Ident;
  return target_id_;
}
inline ::Msg::Ident* ReqAckPlayerChat::release_target_id() {
  clear_has_target_id();
  ::Msg::Ident* temp = target_id_;
  target_id_ = NULL;
  return temp;
}
inline void ReqAckPlayerChat::set_allocated_target_id(::Msg::Ident* target_id) {
  delete target_id_;
  target_id_ = target_id;
  if (target_id) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
}

// repeated .Msg.ReqAckPlayerChat.ChatContainer Container_data = 6;
inline int ReqAckPlayerChat::container_data_size() const {
  return container_data_.size();
}
inline void ReqAckPlayerChat::clear_container_data() {
  container_data_.Clear();
}
inline const ::Msg::ReqAckPlayerChat_ChatContainer& ReqAckPlayerChat::container_data(int index) const {
  return container_data_.Get(index);
}
inline ::Msg::ReqAckPlayerChat_ChatContainer* ReqAckPlayerChat::mutable_container_data(int index) {
  return container_data_.Mutable(index);
}
inline ::Msg::ReqAckPlayerChat_ChatContainer* ReqAckPlayerChat::add_container_data() {
  return container_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::ReqAckPlayerChat_ChatContainer >&
ReqAckPlayerChat::container_data() const {
  return container_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::ReqAckPlayerChat_ChatContainer >*
ReqAckPlayerChat::mutable_container_data() {
  return &container_data_;
}

// -------------------------------------------------------------------

// EffectData

// required .Msg.Ident effect_ident = 1;
inline bool EffectData::has_effect_ident() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectData::set_has_effect_ident() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectData::clear_has_effect_ident() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectData::clear_effect_ident() {
  if (effect_ident_ != NULL) effect_ident_->::Msg::Ident::Clear();
  clear_has_effect_ident();
}
inline const ::Msg::Ident& EffectData::effect_ident() const {
  return effect_ident_ != NULL ? *effect_ident_ : *default_instance_->effect_ident_;
}
inline ::Msg::Ident* EffectData::mutable_effect_ident() {
  set_has_effect_ident();
  if (effect_ident_ == NULL) effect_ident_ = new ::Msg::Ident;
  return effect_ident_;
}
inline ::Msg::Ident* EffectData::release_effect_ident() {
  clear_has_effect_ident();
  ::Msg::Ident* temp = effect_ident_;
  effect_ident_ = NULL;
  return temp;
}
inline void EffectData::set_allocated_effect_ident(::Msg::Ident* effect_ident) {
  delete effect_ident_;
  effect_ident_ = effect_ident;
  if (effect_ident) {
    set_has_effect_ident();
  } else {
    clear_has_effect_ident();
  }
}

// required int32 effect_value = 2;
inline bool EffectData::has_effect_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectData::set_has_effect_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectData::clear_has_effect_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectData::clear_effect_value() {
  effect_value_ = 0;
  clear_has_effect_value();
}
inline ::google::protobuf::int32 EffectData::effect_value() const {
  return effect_value_;
}
inline void EffectData::set_effect_value(::google::protobuf::int32 value) {
  set_has_effect_value();
  effect_value_ = value;
}

// required .Msg.EffectData.EResultType effect_rlt = 3;
inline bool EffectData::has_effect_rlt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectData::set_has_effect_rlt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectData::clear_has_effect_rlt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectData::clear_effect_rlt() {
  effect_rlt_ = 0;
  clear_has_effect_rlt();
}
inline ::Msg::EffectData_EResultType EffectData::effect_rlt() const {
  return static_cast< ::Msg::EffectData_EResultType >(effect_rlt_);
}
inline void EffectData::set_effect_rlt(::Msg::EffectData_EResultType value) {
  assert(::Msg::EffectData_EResultType_IsValid(value));
  set_has_effect_rlt();
  effect_rlt_ = value;
}

// -------------------------------------------------------------------

// ReqAckUseSkill

// required .Msg.Ident user = 1;
inline bool ReqAckUseSkill::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckUseSkill::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckUseSkill::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckUseSkill::clear_user() {
  if (user_ != NULL) user_->::Msg::Ident::Clear();
  clear_has_user();
}
inline const ::Msg::Ident& ReqAckUseSkill::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::Msg::Ident* ReqAckUseSkill::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::Msg::Ident;
  return user_;
}
inline ::Msg::Ident* ReqAckUseSkill::release_user() {
  clear_has_user();
  ::Msg::Ident* temp = user_;
  user_ = NULL;
  return temp;
}
inline void ReqAckUseSkill::set_allocated_user(::Msg::Ident* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// required bytes skill_id = 2;
inline bool ReqAckUseSkill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckUseSkill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckUseSkill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckUseSkill::clear_skill_id() {
  if (skill_id_ != &::google::protobuf::internal::kEmptyString) {
    skill_id_->clear();
  }
  clear_has_skill_id();
}
inline const ::std::string& ReqAckUseSkill::skill_id() const {
  return *skill_id_;
}
inline void ReqAckUseSkill::set_skill_id(const ::std::string& value) {
  set_has_skill_id();
  if (skill_id_ == &::google::protobuf::internal::kEmptyString) {
    skill_id_ = new ::std::string;
  }
  skill_id_->assign(value);
}
inline void ReqAckUseSkill::set_skill_id(const char* value) {
  set_has_skill_id();
  if (skill_id_ == &::google::protobuf::internal::kEmptyString) {
    skill_id_ = new ::std::string;
  }
  skill_id_->assign(value);
}
inline void ReqAckUseSkill::set_skill_id(const void* value, size_t size) {
  set_has_skill_id();
  if (skill_id_ == &::google::protobuf::internal::kEmptyString) {
    skill_id_ = new ::std::string;
  }
  skill_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckUseSkill::mutable_skill_id() {
  set_has_skill_id();
  if (skill_id_ == &::google::protobuf::internal::kEmptyString) {
    skill_id_ = new ::std::string;
  }
  return skill_id_;
}
inline ::std::string* ReqAckUseSkill::release_skill_id() {
  clear_has_skill_id();
  if (skill_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skill_id_;
    skill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckUseSkill::set_allocated_skill_id(::std::string* skill_id) {
  if (skill_id_ != &::google::protobuf::internal::kEmptyString) {
    delete skill_id_;
  }
  if (skill_id) {
    set_has_skill_id();
    skill_id_ = skill_id;
  } else {
    clear_has_skill_id();
    skill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 use_index = 3;
inline bool ReqAckUseSkill::has_use_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckUseSkill::set_has_use_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckUseSkill::clear_has_use_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckUseSkill::clear_use_index() {
  use_index_ = 0;
  clear_has_use_index();
}
inline ::google::protobuf::int32 ReqAckUseSkill::use_index() const {
  return use_index_;
}
inline void ReqAckUseSkill::set_use_index(::google::protobuf::int32 value) {
  set_has_use_index();
  use_index_ = value;
}

// repeated .Msg.EffectData effect_data = 4;
inline int ReqAckUseSkill::effect_data_size() const {
  return effect_data_.size();
}
inline void ReqAckUseSkill::clear_effect_data() {
  effect_data_.Clear();
}
inline const ::Msg::EffectData& ReqAckUseSkill::effect_data(int index) const {
  return effect_data_.Get(index);
}
inline ::Msg::EffectData* ReqAckUseSkill::mutable_effect_data(int index) {
  return effect_data_.Mutable(index);
}
inline ::Msg::EffectData* ReqAckUseSkill::add_effect_data() {
  return effect_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >&
ReqAckUseSkill::effect_data() const {
  return effect_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >*
ReqAckUseSkill::mutable_effect_data() {
  return &effect_data_;
}

// -------------------------------------------------------------------

// ReqAckUseItem

// required .Msg.Ident user = 1;
inline bool ReqAckUseItem::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckUseItem::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckUseItem::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckUseItem::clear_user() {
  if (user_ != NULL) user_->::Msg::Ident::Clear();
  clear_has_user();
}
inline const ::Msg::Ident& ReqAckUseItem::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::Msg::Ident* ReqAckUseItem::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::Msg::Ident;
  return user_;
}
inline ::Msg::Ident* ReqAckUseItem::release_user() {
  clear_has_user();
  ::Msg::Ident* temp = user_;
  user_ = NULL;
  return temp;
}
inline void ReqAckUseItem::set_allocated_user(::Msg::Ident* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// required .Msg.Ident item_guid = 2;
inline bool ReqAckUseItem::has_item_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckUseItem::set_has_item_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckUseItem::clear_has_item_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckUseItem::clear_item_guid() {
  if (item_guid_ != NULL) item_guid_->::Msg::Ident::Clear();
  clear_has_item_guid();
}
inline const ::Msg::Ident& ReqAckUseItem::item_guid() const {
  return item_guid_ != NULL ? *item_guid_ : *default_instance_->item_guid_;
}
inline ::Msg::Ident* ReqAckUseItem::mutable_item_guid() {
  set_has_item_guid();
  if (item_guid_ == NULL) item_guid_ = new ::Msg::Ident;
  return item_guid_;
}
inline ::Msg::Ident* ReqAckUseItem::release_item_guid() {
  clear_has_item_guid();
  ::Msg::Ident* temp = item_guid_;
  item_guid_ = NULL;
  return temp;
}
inline void ReqAckUseItem::set_allocated_item_guid(::Msg::Ident* item_guid) {
  delete item_guid_;
  item_guid_ = item_guid;
  if (item_guid) {
    set_has_item_guid();
  } else {
    clear_has_item_guid();
  }
}

// repeated .Msg.EffectData effect_data = 3;
inline int ReqAckUseItem::effect_data_size() const {
  return effect_data_.size();
}
inline void ReqAckUseItem::clear_effect_data() {
  effect_data_.Clear();
}
inline const ::Msg::EffectData& ReqAckUseItem::effect_data(int index) const {
  return effect_data_.Get(index);
}
inline ::Msg::EffectData* ReqAckUseItem::mutable_effect_data(int index) {
  return effect_data_.Mutable(index);
}
inline ::Msg::EffectData* ReqAckUseItem::add_effect_data() {
  return effect_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >&
ReqAckUseItem::effect_data() const {
  return effect_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::EffectData >*
ReqAckUseItem::mutable_effect_data() {
  return &effect_data_;
}

// required .Msg.ItemStruct item = 4;
inline bool ReqAckUseItem::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckUseItem::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckUseItem::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckUseItem::clear_item() {
  if (item_ != NULL) item_->::Msg::ItemStruct::Clear();
  clear_has_item();
}
inline const ::Msg::ItemStruct& ReqAckUseItem::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::Msg::ItemStruct* ReqAckUseItem::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::Msg::ItemStruct;
  return item_;
}
inline ::Msg::ItemStruct* ReqAckUseItem::release_item() {
  clear_has_item();
  ::Msg::ItemStruct* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ReqAckUseItem::set_allocated_item(::Msg::ItemStruct* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// required .Msg.Ident targetid = 5;
inline bool ReqAckUseItem::has_targetid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqAckUseItem::set_has_targetid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqAckUseItem::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqAckUseItem::clear_targetid() {
  if (targetid_ != NULL) targetid_->::Msg::Ident::Clear();
  clear_has_targetid();
}
inline const ::Msg::Ident& ReqAckUseItem::targetid() const {
  return targetid_ != NULL ? *targetid_ : *default_instance_->targetid_;
}
inline ::Msg::Ident* ReqAckUseItem::mutable_targetid() {
  set_has_targetid();
  if (targetid_ == NULL) targetid_ = new ::Msg::Ident;
  return targetid_;
}
inline ::Msg::Ident* ReqAckUseItem::release_targetid() {
  clear_has_targetid();
  ::Msg::Ident* temp = targetid_;
  targetid_ = NULL;
  return temp;
}
inline void ReqAckUseItem::set_allocated_targetid(::Msg::Ident* targetid) {
  delete targetid_;
  targetid_ = targetid;
  if (targetid) {
    set_has_targetid();
  } else {
    clear_has_targetid();
  }
}

// -------------------------------------------------------------------

// ReqAckSwapScene

// required .Msg.ReqAckSwapScene.EGameSwapType transfer_type = 1;
inline bool ReqAckSwapScene::has_transfer_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckSwapScene::set_has_transfer_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckSwapScene::clear_has_transfer_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckSwapScene::clear_transfer_type() {
  transfer_type_ = 0;
  clear_has_transfer_type();
}
inline ::Msg::ReqAckSwapScene_EGameSwapType ReqAckSwapScene::transfer_type() const {
  return static_cast< ::Msg::ReqAckSwapScene_EGameSwapType >(transfer_type_);
}
inline void ReqAckSwapScene::set_transfer_type(::Msg::ReqAckSwapScene_EGameSwapType value) {
  assert(::Msg::ReqAckSwapScene_EGameSwapType_IsValid(value));
  set_has_transfer_type();
  transfer_type_ = value;
}

// required int32 scene_id = 2;
inline bool ReqAckSwapScene::has_scene_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckSwapScene::set_has_scene_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckSwapScene::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckSwapScene::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 ReqAckSwapScene::scene_id() const {
  return scene_id_;
}
inline void ReqAckSwapScene::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// required int32 line_id = 3;
inline bool ReqAckSwapScene::has_line_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckSwapScene::set_has_line_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckSwapScene::clear_has_line_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckSwapScene::clear_line_id() {
  line_id_ = 0;
  clear_has_line_id();
}
inline ::google::protobuf::int32 ReqAckSwapScene::line_id() const {
  return line_id_;
}
inline void ReqAckSwapScene::set_line_id(::google::protobuf::int32 value) {
  set_has_line_id();
  line_id_ = value;
}

// optional float x = 4;
inline bool ReqAckSwapScene::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckSwapScene::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckSwapScene::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckSwapScene::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ReqAckSwapScene::x() const {
  return x_;
}
inline void ReqAckSwapScene::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 5;
inline bool ReqAckSwapScene::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqAckSwapScene::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqAckSwapScene::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqAckSwapScene::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ReqAckSwapScene::y() const {
  return y_;
}
inline void ReqAckSwapScene::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 6;
inline bool ReqAckSwapScene::has_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqAckSwapScene::set_has_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqAckSwapScene::clear_has_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqAckSwapScene::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float ReqAckSwapScene::z() const {
  return z_;
}
inline void ReqAckSwapScene::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional string data = 7;
inline bool ReqAckSwapScene::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqAckSwapScene::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqAckSwapScene::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqAckSwapScene::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ReqAckSwapScene::data() const {
  return *data_;
}
inline void ReqAckSwapScene::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckSwapScene::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckSwapScene::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckSwapScene::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ReqAckSwapScene::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckSwapScene::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckHomeScene

// optional string data = 1;
inline bool ReqAckHomeScene::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckHomeScene::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckHomeScene::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckHomeScene::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ReqAckHomeScene::data() const {
  return *data_;
}
inline void ReqAckHomeScene::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckHomeScene::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReqAckHomeScene::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckHomeScene::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ReqAckHomeScene::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckHomeScene::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ItemStruct

// required string item_id = 1;
inline bool ItemStruct::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemStruct::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemStruct::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemStruct::clear_item_id() {
  if (item_id_ != &::google::protobuf::internal::kEmptyString) {
    item_id_->clear();
  }
  clear_has_item_id();
}
inline const ::std::string& ItemStruct::item_id() const {
  return *item_id_;
}
inline void ItemStruct::set_item_id(const ::std::string& value) {
  set_has_item_id();
  if (item_id_ == &::google::protobuf::internal::kEmptyString) {
    item_id_ = new ::std::string;
  }
  item_id_->assign(value);
}
inline void ItemStruct::set_item_id(const char* value) {
  set_has_item_id();
  if (item_id_ == &::google::protobuf::internal::kEmptyString) {
    item_id_ = new ::std::string;
  }
  item_id_->assign(value);
}
inline void ItemStruct::set_item_id(const char* value, size_t size) {
  set_has_item_id();
  if (item_id_ == &::google::protobuf::internal::kEmptyString) {
    item_id_ = new ::std::string;
  }
  item_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemStruct::mutable_item_id() {
  set_has_item_id();
  if (item_id_ == &::google::protobuf::internal::kEmptyString) {
    item_id_ = new ::std::string;
  }
  return item_id_;
}
inline ::std::string* ItemStruct::release_item_id() {
  clear_has_item_id();
  if (item_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = item_id_;
    item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemStruct::set_allocated_item_id(::std::string* item_id) {
  if (item_id_ != &::google::protobuf::internal::kEmptyString) {
    delete item_id_;
  }
  if (item_id) {
    set_has_item_id();
    item_id_ = item_id;
  } else {
    clear_has_item_id();
    item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 item_count = 2;
inline bool ItemStruct::has_item_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemStruct::set_has_item_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemStruct::clear_has_item_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemStruct::clear_item_count() {
  item_count_ = 0;
  clear_has_item_count();
}
inline ::google::protobuf::int32 ItemStruct::item_count() const {
  return item_count_;
}
inline void ItemStruct::set_item_count(::google::protobuf::int32 value) {
  set_has_item_count();
  item_count_ = value;
}

// -------------------------------------------------------------------

// CurrencyStruct

// required int32 currency_type = 1;
inline bool CurrencyStruct::has_currency_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrencyStruct::set_has_currency_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrencyStruct::clear_has_currency_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrencyStruct::clear_currency_type() {
  currency_type_ = 0;
  clear_has_currency_type();
}
inline ::google::protobuf::int32 CurrencyStruct::currency_type() const {
  return currency_type_;
}
inline void CurrencyStruct::set_currency_type(::google::protobuf::int32 value) {
  set_has_currency_type();
  currency_type_ = value;
}

// required int32 currency_count = 2;
inline bool CurrencyStruct::has_currency_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrencyStruct::set_has_currency_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrencyStruct::clear_has_currency_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrencyStruct::clear_currency_count() {
  currency_count_ = 0;
  clear_has_currency_count();
}
inline ::google::protobuf::int32 CurrencyStruct::currency_count() const {
  return currency_count_;
}
inline void CurrencyStruct::set_currency_count(::google::protobuf::int32 value) {
  set_has_currency_count();
  currency_count_ = value;
}

// -------------------------------------------------------------------

// ReqAckStartBattle

// required int32 gold = 1;
inline bool ReqAckStartBattle::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckStartBattle::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckStartBattle::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckStartBattle::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 ReqAckStartBattle::gold() const {
  return gold_;
}
inline void ReqAckStartBattle::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// required int32 diamond = 2;
inline bool ReqAckStartBattle::has_diamond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckStartBattle::set_has_diamond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckStartBattle::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckStartBattle::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 ReqAckStartBattle::diamond() const {
  return diamond_;
}
inline void ReqAckStartBattle::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
}

// -------------------------------------------------------------------

// ReqEndBattle

// -------------------------------------------------------------------

// AckEndBattle

// required int32 win = 1;
inline bool AckEndBattle::has_win() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckEndBattle::set_has_win() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckEndBattle::clear_has_win() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckEndBattle::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 AckEndBattle::win() const {
  return win_;
}
inline void AckEndBattle::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// required int32 star = 2;
inline bool AckEndBattle::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckEndBattle::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckEndBattle::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckEndBattle::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 AckEndBattle::star() const {
  return star_;
}
inline void AckEndBattle::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// required int32 gold = 3;
inline bool AckEndBattle::has_gold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckEndBattle::set_has_gold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckEndBattle::clear_has_gold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckEndBattle::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 AckEndBattle::gold() const {
  return gold_;
}
inline void AckEndBattle::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// required int32 exp = 4;
inline bool AckEndBattle::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckEndBattle::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckEndBattle::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckEndBattle::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckEndBattle::exp() const {
  return exp_;
}
inline void AckEndBattle::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// required int32 diamond = 5;
inline bool AckEndBattle::has_diamond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckEndBattle::set_has_diamond() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckEndBattle::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckEndBattle::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 AckEndBattle::diamond() const {
  return diamond_;
}
inline void AckEndBattle::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
}

// repeated .Msg.ItemStruct item_list = 6;
inline int AckEndBattle::item_list_size() const {
  return item_list_.size();
}
inline void AckEndBattle::clear_item_list() {
  item_list_.Clear();
}
inline const ::Msg::ItemStruct& AckEndBattle::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Msg::ItemStruct* AckEndBattle::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Msg::ItemStruct* AckEndBattle::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >&
AckEndBattle::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >*
AckEndBattle::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// ReqPickDropItem

// required .Msg.Ident item_guid = 2;
inline bool ReqPickDropItem::has_item_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPickDropItem::set_has_item_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPickDropItem::clear_has_item_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPickDropItem::clear_item_guid() {
  if (item_guid_ != NULL) item_guid_->::Msg::Ident::Clear();
  clear_has_item_guid();
}
inline const ::Msg::Ident& ReqPickDropItem::item_guid() const {
  return item_guid_ != NULL ? *item_guid_ : *default_instance_->item_guid_;
}
inline ::Msg::Ident* ReqPickDropItem::mutable_item_guid() {
  set_has_item_guid();
  if (item_guid_ == NULL) item_guid_ = new ::Msg::Ident;
  return item_guid_;
}
inline ::Msg::Ident* ReqPickDropItem::release_item_guid() {
  clear_has_item_guid();
  ::Msg::Ident* temp = item_guid_;
  item_guid_ = NULL;
  return temp;
}
inline void ReqPickDropItem::set_allocated_item_guid(::Msg::Ident* item_guid) {
  delete item_guid_;
  item_guid_ = item_guid;
  if (item_guid) {
    set_has_item_guid();
  } else {
    clear_has_item_guid();
  }
}

// -------------------------------------------------------------------

// ReqAcceptTask

// required bytes task_id = 1;
inline bool ReqAcceptTask::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAcceptTask::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAcceptTask::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAcceptTask::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& ReqAcceptTask::task_id() const {
  return *task_id_;
}
inline void ReqAcceptTask::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void ReqAcceptTask::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void ReqAcceptTask::set_task_id(const void* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAcceptTask::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* ReqAcceptTask::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAcceptTask::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqCompeleteTask

// required bytes task_id = 1;
inline bool ReqCompeleteTask::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCompeleteTask::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCompeleteTask::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCompeleteTask::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& ReqCompeleteTask::task_id() const {
  return *task_id_;
}
inline void ReqCompeleteTask::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void ReqCompeleteTask::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void ReqCompeleteTask::set_task_id(const void* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCompeleteTask::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* ReqCompeleteTask::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCompeleteTask::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqWearEquip

// required .Msg.Ident equipid = 1;
inline bool ReqWearEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqWearEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqWearEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqWearEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& ReqWearEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* ReqWearEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* ReqWearEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void ReqWearEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required .Msg.Ident Targetid = 2;
inline bool ReqWearEquip::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqWearEquip::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqWearEquip::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqWearEquip::clear_targetid() {
  if (targetid_ != NULL) targetid_->::Msg::Ident::Clear();
  clear_has_targetid();
}
inline const ::Msg::Ident& ReqWearEquip::targetid() const {
  return targetid_ != NULL ? *targetid_ : *default_instance_->targetid_;
}
inline ::Msg::Ident* ReqWearEquip::mutable_targetid() {
  set_has_targetid();
  if (targetid_ == NULL) targetid_ = new ::Msg::Ident;
  return targetid_;
}
inline ::Msg::Ident* ReqWearEquip::release_targetid() {
  clear_has_targetid();
  ::Msg::Ident* temp = targetid_;
  targetid_ = NULL;
  return temp;
}
inline void ReqWearEquip::set_allocated_targetid(::Msg::Ident* targetid) {
  delete targetid_;
  targetid_ = targetid;
  if (targetid) {
    set_has_targetid();
  } else {
    clear_has_targetid();
  }
}

// -------------------------------------------------------------------

// TakeOffEquip

// required .Msg.Ident equipid = 1;
inline bool TakeOffEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeOffEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeOffEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeOffEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& TakeOffEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* TakeOffEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* TakeOffEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void TakeOffEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required .Msg.Ident Targetid = 2;
inline bool TakeOffEquip::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TakeOffEquip::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TakeOffEquip::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TakeOffEquip::clear_targetid() {
  if (targetid_ != NULL) targetid_->::Msg::Ident::Clear();
  clear_has_targetid();
}
inline const ::Msg::Ident& TakeOffEquip::targetid() const {
  return targetid_ != NULL ? *targetid_ : *default_instance_->targetid_;
}
inline ::Msg::Ident* TakeOffEquip::mutable_targetid() {
  set_has_targetid();
  if (targetid_ == NULL) targetid_ = new ::Msg::Ident;
  return targetid_;
}
inline ::Msg::Ident* TakeOffEquip::release_targetid() {
  clear_has_targetid();
  ::Msg::Ident* temp = targetid_;
  targetid_ = NULL;
  return temp;
}
inline void TakeOffEquip::set_allocated_targetid(::Msg::Ident* targetid) {
  delete targetid_;
  targetid_ = targetid;
  if (targetid) {
    set_has_targetid();
  } else {
    clear_has_targetid();
  }
}

// -------------------------------------------------------------------

// ReqAckJoinActivity

// required .Msg.ReqAckJoinActivity.EGameActivityType activity_type = 1;
inline bool ReqAckJoinActivity::has_activity_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckJoinActivity::set_has_activity_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckJoinActivity::clear_has_activity_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckJoinActivity::clear_activity_type() {
  activity_type_ = 0;
  clear_has_activity_type();
}
inline ::Msg::ReqAckJoinActivity_EGameActivityType ReqAckJoinActivity::activity_type() const {
  return static_cast< ::Msg::ReqAckJoinActivity_EGameActivityType >(activity_type_);
}
inline void ReqAckJoinActivity::set_activity_type(::Msg::ReqAckJoinActivity_EGameActivityType value) {
  assert(::Msg::ReqAckJoinActivity_EGameActivityType_IsValid(value));
  set_has_activity_type();
  activity_type_ = value;
}

// required .Msg.ReqAckJoinActivity.EGameActivitySubType sub_activity_type = 2;
inline bool ReqAckJoinActivity::has_sub_activity_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckJoinActivity::set_has_sub_activity_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckJoinActivity::clear_has_sub_activity_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckJoinActivity::clear_sub_activity_type() {
  sub_activity_type_ = 0;
  clear_has_sub_activity_type();
}
inline ::Msg::ReqAckJoinActivity_EGameActivitySubType ReqAckJoinActivity::sub_activity_type() const {
  return static_cast< ::Msg::ReqAckJoinActivity_EGameActivitySubType >(sub_activity_type_);
}
inline void ReqAckJoinActivity::set_sub_activity_type(::Msg::ReqAckJoinActivity_EGameActivitySubType value) {
  assert(::Msg::ReqAckJoinActivity_EGameActivitySubType_IsValid(value));
  set_has_sub_activity_type();
  sub_activity_type_ = value;
}

// -------------------------------------------------------------------

// ReqAckCreateGuild

// required .Msg.Ident guild_id = 1;
inline bool ReqAckCreateGuild::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckCreateGuild::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckCreateGuild::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckCreateGuild::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqAckCreateGuild::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqAckCreateGuild::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqAckCreateGuild::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqAckCreateGuild::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// required string guild_name = 2;
inline bool ReqAckCreateGuild::has_guild_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckCreateGuild::set_has_guild_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckCreateGuild::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckCreateGuild::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& ReqAckCreateGuild::guild_name() const {
  return *guild_name_;
}
inline void ReqAckCreateGuild::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckCreateGuild::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckCreateGuild::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckCreateGuild::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* ReqAckCreateGuild::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckCreateGuild::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqSearchGuild

// required string guild_name = 1;
inline bool ReqSearchGuild::has_guild_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSearchGuild::set_has_guild_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSearchGuild::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSearchGuild::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& ReqSearchGuild::guild_name() const {
  return *guild_name_;
}
inline void ReqSearchGuild::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqSearchGuild::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqSearchGuild::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqSearchGuild::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* ReqSearchGuild::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqSearchGuild::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckSearchGuild_SearchGuildObject

// required .Msg.Ident guild_ID = 1;
inline bool AckSearchGuild_SearchGuildObject::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& AckSearchGuild_SearchGuildObject::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* AckSearchGuild_SearchGuildObject::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* AckSearchGuild_SearchGuildObject::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void AckSearchGuild_SearchGuildObject::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// required string guild_name = 2;
inline bool AckSearchGuild_SearchGuildObject::has_guild_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& AckSearchGuild_SearchGuildObject::guild_name() const {
  return *guild_name_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void AckSearchGuild_SearchGuildObject::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void AckSearchGuild_SearchGuildObject::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckSearchGuild_SearchGuildObject::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* AckSearchGuild_SearchGuildObject::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckSearchGuild_SearchGuildObject::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string guild_icon = 3;
inline bool AckSearchGuild_SearchGuildObject::has_guild_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_icon() {
  if (guild_icon_ != &::google::protobuf::internal::kEmptyString) {
    guild_icon_->clear();
  }
  clear_has_guild_icon();
}
inline const ::std::string& AckSearchGuild_SearchGuildObject::guild_icon() const {
  return *guild_icon_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_icon(const ::std::string& value) {
  set_has_guild_icon();
  if (guild_icon_ == &::google::protobuf::internal::kEmptyString) {
    guild_icon_ = new ::std::string;
  }
  guild_icon_->assign(value);
}
inline void AckSearchGuild_SearchGuildObject::set_guild_icon(const char* value) {
  set_has_guild_icon();
  if (guild_icon_ == &::google::protobuf::internal::kEmptyString) {
    guild_icon_ = new ::std::string;
  }
  guild_icon_->assign(value);
}
inline void AckSearchGuild_SearchGuildObject::set_guild_icon(const char* value, size_t size) {
  set_has_guild_icon();
  if (guild_icon_ == &::google::protobuf::internal::kEmptyString) {
    guild_icon_ = new ::std::string;
  }
  guild_icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckSearchGuild_SearchGuildObject::mutable_guild_icon() {
  set_has_guild_icon();
  if (guild_icon_ == &::google::protobuf::internal::kEmptyString) {
    guild_icon_ = new ::std::string;
  }
  return guild_icon_;
}
inline ::std::string* AckSearchGuild_SearchGuildObject::release_guild_icon() {
  clear_has_guild_icon();
  if (guild_icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_icon_;
    guild_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckSearchGuild_SearchGuildObject::set_allocated_guild_icon(::std::string* guild_icon) {
  if (guild_icon_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_icon_;
  }
  if (guild_icon) {
    set_has_guild_icon();
    guild_icon_ = guild_icon;
  } else {
    clear_has_guild_icon();
    guild_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 guild_member_count = 4;
inline bool AckSearchGuild_SearchGuildObject::has_guild_member_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_member_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_member_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_member_count() {
  guild_member_count_ = 0;
  clear_has_guild_member_count();
}
inline ::google::protobuf::int32 AckSearchGuild_SearchGuildObject::guild_member_count() const {
  return guild_member_count_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_member_count(::google::protobuf::int32 value) {
  set_has_guild_member_count();
  guild_member_count_ = value;
}

// required int32 guild_member_max_count = 5;
inline bool AckSearchGuild_SearchGuildObject::has_guild_member_max_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_member_max_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_member_max_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_member_max_count() {
  guild_member_max_count_ = 0;
  clear_has_guild_member_max_count();
}
inline ::google::protobuf::int32 AckSearchGuild_SearchGuildObject::guild_member_max_count() const {
  return guild_member_max_count_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_member_max_count(::google::protobuf::int32 value) {
  set_has_guild_member_max_count();
  guild_member_max_count_ = value;
}

// required int32 guild_honor = 6;
inline bool AckSearchGuild_SearchGuildObject::has_guild_honor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_honor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_honor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_honor() {
  guild_honor_ = 0;
  clear_has_guild_honor();
}
inline ::google::protobuf::int32 AckSearchGuild_SearchGuildObject::guild_honor() const {
  return guild_honor_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_honor(::google::protobuf::int32 value) {
  set_has_guild_honor();
  guild_honor_ = value;
}

// required int32 guild_rank = 7;
inline bool AckSearchGuild_SearchGuildObject::has_guild_rank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckSearchGuild_SearchGuildObject::set_has_guild_rank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckSearchGuild_SearchGuildObject::clear_has_guild_rank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckSearchGuild_SearchGuildObject::clear_guild_rank() {
  guild_rank_ = 0;
  clear_has_guild_rank();
}
inline ::google::protobuf::int32 AckSearchGuild_SearchGuildObject::guild_rank() const {
  return guild_rank_;
}
inline void AckSearchGuild_SearchGuildObject::set_guild_rank(::google::protobuf::int32 value) {
  set_has_guild_rank();
  guild_rank_ = value;
}

// -------------------------------------------------------------------

// AckSearchGuild

// repeated .Msg.AckSearchGuild.SearchGuildObject guild_list = 1;
inline int AckSearchGuild::guild_list_size() const {
  return guild_list_.size();
}
inline void AckSearchGuild::clear_guild_list() {
  guild_list_.Clear();
}
inline const ::Msg::AckSearchGuild_SearchGuildObject& AckSearchGuild::guild_list(int index) const {
  return guild_list_.Get(index);
}
inline ::Msg::AckSearchGuild_SearchGuildObject* AckSearchGuild::mutable_guild_list(int index) {
  return guild_list_.Mutable(index);
}
inline ::Msg::AckSearchGuild_SearchGuildObject* AckSearchGuild::add_guild_list() {
  return guild_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::AckSearchGuild_SearchGuildObject >&
AckSearchGuild::guild_list() const {
  return guild_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::AckSearchGuild_SearchGuildObject >*
AckSearchGuild::mutable_guild_list() {
  return &guild_list_;
}

// -------------------------------------------------------------------

// ReqAckJoinGuild

// required .Msg.Ident guild_id = 1;
inline bool ReqAckJoinGuild::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckJoinGuild::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckJoinGuild::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckJoinGuild::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqAckJoinGuild::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqAckJoinGuild::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqAckJoinGuild::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqAckJoinGuild::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// required string guild_name = 2;
inline bool ReqAckJoinGuild::has_guild_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckJoinGuild::set_has_guild_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckJoinGuild::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckJoinGuild::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& ReqAckJoinGuild::guild_name() const {
  return *guild_name_;
}
inline void ReqAckJoinGuild::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckJoinGuild::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckJoinGuild::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckJoinGuild::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* ReqAckJoinGuild::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckJoinGuild::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckLeaveGuild

// required .Msg.Ident guild_id = 1;
inline bool ReqAckLeaveGuild::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckLeaveGuild::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckLeaveGuild::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckLeaveGuild::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqAckLeaveGuild::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqAckLeaveGuild::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqAckLeaveGuild::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqAckLeaveGuild::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// required string guild_name = 2;
inline bool ReqAckLeaveGuild::has_guild_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckLeaveGuild::set_has_guild_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckLeaveGuild::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckLeaveGuild::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& ReqAckLeaveGuild::guild_name() const {
  return *guild_name_;
}
inline void ReqAckLeaveGuild::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckLeaveGuild::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ReqAckLeaveGuild::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAckLeaveGuild::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* ReqAckLeaveGuild::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqAckLeaveGuild::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckOprGuildMember

// required .Msg.Ident guild_id = 1;
inline bool ReqAckOprGuildMember::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckOprGuildMember::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckOprGuildMember::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckOprGuildMember::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqAckOprGuildMember::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqAckOprGuildMember::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqAckOprGuildMember::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqAckOprGuildMember::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// required .Msg.Ident member_id = 2;
inline bool ReqAckOprGuildMember::has_member_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckOprGuildMember::set_has_member_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckOprGuildMember::clear_has_member_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckOprGuildMember::clear_member_id() {
  if (member_id_ != NULL) member_id_->::Msg::Ident::Clear();
  clear_has_member_id();
}
inline const ::Msg::Ident& ReqAckOprGuildMember::member_id() const {
  return member_id_ != NULL ? *member_id_ : *default_instance_->member_id_;
}
inline ::Msg::Ident* ReqAckOprGuildMember::mutable_member_id() {
  set_has_member_id();
  if (member_id_ == NULL) member_id_ = new ::Msg::Ident;
  return member_id_;
}
inline ::Msg::Ident* ReqAckOprGuildMember::release_member_id() {
  clear_has_member_id();
  ::Msg::Ident* temp = member_id_;
  member_id_ = NULL;
  return temp;
}
inline void ReqAckOprGuildMember::set_allocated_member_id(::Msg::Ident* member_id) {
  delete member_id_;
  member_id_ = member_id;
  if (member_id) {
    set_has_member_id();
  } else {
    clear_has_member_id();
  }
}

// required .Msg.ReqAckOprGuildMember.EGGuildMemberOprType type = 3;
inline bool ReqAckOprGuildMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckOprGuildMember::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckOprGuildMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckOprGuildMember::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Msg::ReqAckOprGuildMember_EGGuildMemberOprType ReqAckOprGuildMember::type() const {
  return static_cast< ::Msg::ReqAckOprGuildMember_EGGuildMemberOprType >(type_);
}
inline void ReqAckOprGuildMember::set_type(::Msg::ReqAckOprGuildMember_EGGuildMemberOprType value) {
  assert(::Msg::ReqAckOprGuildMember_EGGuildMemberOprType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ReqEnterGuildEctype

// required .Msg.Ident guild_id = 1;
inline bool ReqEnterGuildEctype::has_guild_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEnterGuildEctype::set_has_guild_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEnterGuildEctype::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEnterGuildEctype::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqEnterGuildEctype::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqEnterGuildEctype::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqEnterGuildEctype::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqEnterGuildEctype::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// -------------------------------------------------------------------

// ReqIntensifylevelToEquip

// required .Msg.Ident equipid = 1;
inline bool ReqIntensifylevelToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqIntensifylevelToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqIntensifylevelToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqIntensifylevelToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& ReqIntensifylevelToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* ReqIntensifylevelToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* ReqIntensifylevelToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void ReqIntensifylevelToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// -------------------------------------------------------------------

// AckIntensifylevelToEquip

// required .Msg.Ident equipid = 1;
inline bool AckIntensifylevelToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckIntensifylevelToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckIntensifylevelToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckIntensifylevelToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& AckIntensifylevelToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* AckIntensifylevelToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* AckIntensifylevelToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void AckIntensifylevelToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required int32 result = 2;
inline bool AckIntensifylevelToEquip::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckIntensifylevelToEquip::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckIntensifylevelToEquip::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckIntensifylevelToEquip::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckIntensifylevelToEquip::result() const {
  return result_;
}
inline void AckIntensifylevelToEquip::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ReqHoleToEquip

// required .Msg.Ident equipid = 1;
inline bool ReqHoleToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHoleToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHoleToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHoleToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& ReqHoleToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* ReqHoleToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* ReqHoleToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void ReqHoleToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// -------------------------------------------------------------------

// AckHoleToEquip

// required .Msg.Ident equipid = 1;
inline bool AckHoleToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHoleToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHoleToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHoleToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& AckHoleToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* AckHoleToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* AckHoleToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void AckHoleToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required int32 result = 2;
inline bool AckHoleToEquip::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckHoleToEquip::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckHoleToEquip::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckHoleToEquip::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckHoleToEquip::result() const {
  return result_;
}
inline void AckHoleToEquip::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ReqInlaystoneToEquip

// required .Msg.Ident equipid = 1;
inline bool ReqInlaystoneToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqInlaystoneToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqInlaystoneToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqInlaystoneToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& ReqInlaystoneToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* ReqInlaystoneToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* ReqInlaystoneToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void ReqInlaystoneToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required bytes stoneid = 2;
inline bool ReqInlaystoneToEquip::has_stoneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqInlaystoneToEquip::set_has_stoneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqInlaystoneToEquip::clear_has_stoneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqInlaystoneToEquip::clear_stoneid() {
  if (stoneid_ != &::google::protobuf::internal::kEmptyString) {
    stoneid_->clear();
  }
  clear_has_stoneid();
}
inline const ::std::string& ReqInlaystoneToEquip::stoneid() const {
  return *stoneid_;
}
inline void ReqInlaystoneToEquip::set_stoneid(const ::std::string& value) {
  set_has_stoneid();
  if (stoneid_ == &::google::protobuf::internal::kEmptyString) {
    stoneid_ = new ::std::string;
  }
  stoneid_->assign(value);
}
inline void ReqInlaystoneToEquip::set_stoneid(const char* value) {
  set_has_stoneid();
  if (stoneid_ == &::google::protobuf::internal::kEmptyString) {
    stoneid_ = new ::std::string;
  }
  stoneid_->assign(value);
}
inline void ReqInlaystoneToEquip::set_stoneid(const void* value, size_t size) {
  set_has_stoneid();
  if (stoneid_ == &::google::protobuf::internal::kEmptyString) {
    stoneid_ = new ::std::string;
  }
  stoneid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqInlaystoneToEquip::mutable_stoneid() {
  set_has_stoneid();
  if (stoneid_ == &::google::protobuf::internal::kEmptyString) {
    stoneid_ = new ::std::string;
  }
  return stoneid_;
}
inline ::std::string* ReqInlaystoneToEquip::release_stoneid() {
  clear_has_stoneid();
  if (stoneid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stoneid_;
    stoneid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqInlaystoneToEquip::set_allocated_stoneid(::std::string* stoneid) {
  if (stoneid_ != &::google::protobuf::internal::kEmptyString) {
    delete stoneid_;
  }
  if (stoneid) {
    set_has_stoneid();
    stoneid_ = stoneid;
  } else {
    clear_has_stoneid();
    stoneid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 hole_index = 3;
inline bool ReqInlaystoneToEquip::has_hole_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqInlaystoneToEquip::set_has_hole_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqInlaystoneToEquip::clear_has_hole_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqInlaystoneToEquip::clear_hole_index() {
  hole_index_ = 0;
  clear_has_hole_index();
}
inline ::google::protobuf::int32 ReqInlaystoneToEquip::hole_index() const {
  return hole_index_;
}
inline void ReqInlaystoneToEquip::set_hole_index(::google::protobuf::int32 value) {
  set_has_hole_index();
  hole_index_ = value;
}

// -------------------------------------------------------------------

// AckInlaystoneToEquip

// required .Msg.Ident equipid = 1;
inline bool AckInlaystoneToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckInlaystoneToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckInlaystoneToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckInlaystoneToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& AckInlaystoneToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* AckInlaystoneToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* AckInlaystoneToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void AckInlaystoneToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required int32 result = 2;
inline bool AckInlaystoneToEquip::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckInlaystoneToEquip::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckInlaystoneToEquip::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckInlaystoneToEquip::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckInlaystoneToEquip::result() const {
  return result_;
}
inline void AckInlaystoneToEquip::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ReqElementlevelToEquip

// required .Msg.Ident equipid = 1;
inline bool ReqElementlevelToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqElementlevelToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqElementlevelToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqElementlevelToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& ReqElementlevelToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* ReqElementlevelToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* ReqElementlevelToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void ReqElementlevelToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required .Msg.EGameElementType eElementType = 2;
inline bool ReqElementlevelToEquip::has_eelementtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqElementlevelToEquip::set_has_eelementtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqElementlevelToEquip::clear_has_eelementtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqElementlevelToEquip::clear_eelementtype() {
  eelementtype_ = 0;
  clear_has_eelementtype();
}
inline ::Msg::EGameElementType ReqElementlevelToEquip::eelementtype() const {
  return static_cast< ::Msg::EGameElementType >(eelementtype_);
}
inline void ReqElementlevelToEquip::set_eelementtype(::Msg::EGameElementType value) {
  assert(::Msg::EGameElementType_IsValid(value));
  set_has_eelementtype();
  eelementtype_ = value;
}

// -------------------------------------------------------------------

// AckElementlevelToEquip

// required .Msg.Ident equipid = 1;
inline bool AckElementlevelToEquip::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckElementlevelToEquip::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckElementlevelToEquip::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckElementlevelToEquip::clear_equipid() {
  if (equipid_ != NULL) equipid_->::Msg::Ident::Clear();
  clear_has_equipid();
}
inline const ::Msg::Ident& AckElementlevelToEquip::equipid() const {
  return equipid_ != NULL ? *equipid_ : *default_instance_->equipid_;
}
inline ::Msg::Ident* AckElementlevelToEquip::mutable_equipid() {
  set_has_equipid();
  if (equipid_ == NULL) equipid_ = new ::Msg::Ident;
  return equipid_;
}
inline ::Msg::Ident* AckElementlevelToEquip::release_equipid() {
  clear_has_equipid();
  ::Msg::Ident* temp = equipid_;
  equipid_ = NULL;
  return temp;
}
inline void AckElementlevelToEquip::set_allocated_equipid(::Msg::Ident* equipid) {
  delete equipid_;
  equipid_ = equipid;
  if (equipid) {
    set_has_equipid();
  } else {
    clear_has_equipid();
  }
}

// required int32 result = 2;
inline bool AckElementlevelToEquip::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckElementlevelToEquip::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckElementlevelToEquip::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckElementlevelToEquip::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckElementlevelToEquip::result() const {
  return result_;
}
inline void AckElementlevelToEquip::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ReqSetFightHero

// required .Msg.Ident Heroid = 1;
inline bool ReqSetFightHero::has_heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSetFightHero::set_has_heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSetFightHero::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSetFightHero::clear_heroid() {
  if (heroid_ != NULL) heroid_->::Msg::Ident::Clear();
  clear_has_heroid();
}
inline const ::Msg::Ident& ReqSetFightHero::heroid() const {
  return heroid_ != NULL ? *heroid_ : *default_instance_->heroid_;
}
inline ::Msg::Ident* ReqSetFightHero::mutable_heroid() {
  set_has_heroid();
  if (heroid_ == NULL) heroid_ = new ::Msg::Ident;
  return heroid_;
}
inline ::Msg::Ident* ReqSetFightHero::release_heroid() {
  clear_has_heroid();
  ::Msg::Ident* temp = heroid_;
  heroid_ = NULL;
  return temp;
}
inline void ReqSetFightHero::set_allocated_heroid(::Msg::Ident* heroid) {
  delete heroid_;
  heroid_ = heroid;
  if (heroid) {
    set_has_heroid();
  } else {
    clear_has_heroid();
  }
}

// required int32 Set = 2;
inline bool ReqSetFightHero::has_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSetFightHero::set_has_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSetFightHero::clear_has_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSetFightHero::clear_set() {
  set_ = 0;
  clear_has_set();
}
inline ::google::protobuf::int32 ReqSetFightHero::set() const {
  return set_;
}
inline void ReqSetFightHero::set_set(::google::protobuf::int32 value) {
  set_has_set();
  set_ = value;
}

// -------------------------------------------------------------------

// ReqSwitchFightHero

// required .Msg.Ident Heroid = 1;
inline bool ReqSwitchFightHero::has_heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSwitchFightHero::set_has_heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSwitchFightHero::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSwitchFightHero::clear_heroid() {
  if (heroid_ != NULL) heroid_->::Msg::Ident::Clear();
  clear_has_heroid();
}
inline const ::Msg::Ident& ReqSwitchFightHero::heroid() const {
  return heroid_ != NULL ? *heroid_ : *default_instance_->heroid_;
}
inline ::Msg::Ident* ReqSwitchFightHero::mutable_heroid() {
  set_has_heroid();
  if (heroid_ == NULL) heroid_ = new ::Msg::Ident;
  return heroid_;
}
inline ::Msg::Ident* ReqSwitchFightHero::release_heroid() {
  clear_has_heroid();
  ::Msg::Ident* temp = heroid_;
  heroid_ = NULL;
  return temp;
}
inline void ReqSwitchFightHero::set_allocated_heroid(::Msg::Ident* heroid) {
  delete heroid_;
  heroid_ = heroid;
  if (heroid) {
    set_has_heroid();
  } else {
    clear_has_heroid();
  }
}

// -------------------------------------------------------------------

// ReqMiningTitle

// required int32 x = 1;
inline bool ReqMiningTitle::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMiningTitle::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMiningTitle::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMiningTitle::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ReqMiningTitle::x() const {
  return x_;
}
inline void ReqMiningTitle::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool ReqMiningTitle::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqMiningTitle::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqMiningTitle::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqMiningTitle::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ReqMiningTitle::y() const {
  return y_;
}
inline void ReqMiningTitle::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 opr = 3;
inline bool ReqMiningTitle::has_opr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqMiningTitle::set_has_opr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqMiningTitle::clear_has_opr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqMiningTitle::clear_opr() {
  opr_ = 0;
  clear_has_opr();
}
inline ::google::protobuf::int32 ReqMiningTitle::opr() const {
  return opr_;
}
inline void ReqMiningTitle::set_opr(::google::protobuf::int32 value) {
  set_has_opr();
  opr_ = value;
}

// -------------------------------------------------------------------

// TileState

// required int32 x = 1;
inline bool TileState::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileState::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileState::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileState::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 TileState::x() const {
  return x_;
}
inline void TileState::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool TileState::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileState::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileState::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileState::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 TileState::y() const {
  return y_;
}
inline void TileState::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 opr = 3;
inline bool TileState::has_opr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileState::set_has_opr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileState::clear_has_opr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileState::clear_opr() {
  opr_ = 0;
  clear_has_opr();
}
inline ::google::protobuf::int32 TileState::opr() const {
  return opr_;
}
inline void TileState::set_opr(::google::protobuf::int32 value) {
  set_has_opr();
  opr_ = value;
}

// -------------------------------------------------------------------

// TileBuilding

// required int32 x = 1;
inline bool TileBuilding::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileBuilding::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileBuilding::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileBuilding::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 TileBuilding::x() const {
  return x_;
}
inline void TileBuilding::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool TileBuilding::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileBuilding::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileBuilding::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileBuilding::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 TileBuilding::y() const {
  return y_;
}
inline void TileBuilding::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required string coigID = 3;
inline bool TileBuilding::has_coigid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileBuilding::set_has_coigid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileBuilding::clear_has_coigid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileBuilding::clear_coigid() {
  if (coigid_ != &::google::protobuf::internal::kEmptyString) {
    coigid_->clear();
  }
  clear_has_coigid();
}
inline const ::std::string& TileBuilding::coigid() const {
  return *coigid_;
}
inline void TileBuilding::set_coigid(const ::std::string& value) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(value);
}
inline void TileBuilding::set_coigid(const char* value) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(value);
}
inline void TileBuilding::set_coigid(const char* value, size_t size) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TileBuilding::mutable_coigid() {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  return coigid_;
}
inline ::std::string* TileBuilding::release_coigid() {
  clear_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coigid_;
    coigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TileBuilding::set_allocated_coigid(::std::string* coigid) {
  if (coigid_ != &::google::protobuf::internal::kEmptyString) {
    delete coigid_;
  }
  if (coigid) {
    set_has_coigid();
    coigid_ = coigid;
  } else {
    clear_has_coigid();
    coigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.Ident guid = 4;
inline bool TileBuilding::has_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TileBuilding::set_has_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TileBuilding::clear_has_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TileBuilding::clear_guid() {
  if (guid_ != NULL) guid_->::Msg::Ident::Clear();
  clear_has_guid();
}
inline const ::Msg::Ident& TileBuilding::guid() const {
  return guid_ != NULL ? *guid_ : *default_instance_->guid_;
}
inline ::Msg::Ident* TileBuilding::mutable_guid() {
  set_has_guid();
  if (guid_ == NULL) guid_ = new ::Msg::Ident;
  return guid_;
}
inline ::Msg::Ident* TileBuilding::release_guid() {
  clear_has_guid();
  ::Msg::Ident* temp = guid_;
  guid_ = NULL;
  return temp;
}
inline void TileBuilding::set_allocated_guid(::Msg::Ident* guid) {
  delete guid_;
  guid_ = guid;
  if (guid) {
    set_has_guid();
  } else {
    clear_has_guid();
  }
}

// -------------------------------------------------------------------

// TileNPC

// required int32 x = 1;
inline bool TileNPC::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileNPC::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileNPC::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileNPC::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 TileNPC::x() const {
  return x_;
}
inline void TileNPC::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool TileNPC::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileNPC::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileNPC::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileNPC::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 TileNPC::y() const {
  return y_;
}
inline void TileNPC::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required string coigID = 3;
inline bool TileNPC::has_coigid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileNPC::set_has_coigid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileNPC::clear_has_coigid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileNPC::clear_coigid() {
  if (coigid_ != &::google::protobuf::internal::kEmptyString) {
    coigid_->clear();
  }
  clear_has_coigid();
}
inline const ::std::string& TileNPC::coigid() const {
  return *coigid_;
}
inline void TileNPC::set_coigid(const ::std::string& value) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(value);
}
inline void TileNPC::set_coigid(const char* value) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(value);
}
inline void TileNPC::set_coigid(const char* value, size_t size) {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  coigid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TileNPC::mutable_coigid() {
  set_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    coigid_ = new ::std::string;
  }
  return coigid_;
}
inline ::std::string* TileNPC::release_coigid() {
  clear_has_coigid();
  if (coigid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coigid_;
    coigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TileNPC::set_allocated_coigid(::std::string* coigid) {
  if (coigid_ != &::google::protobuf::internal::kEmptyString) {
    delete coigid_;
  }
  if (coigid) {
    set_has_coigid();
    coigid_ = coigid;
  } else {
    clear_has_coigid();
    coigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.Ident guid = 4;
inline bool TileNPC::has_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TileNPC::set_has_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TileNPC::clear_has_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TileNPC::clear_guid() {
  if (guid_ != NULL) guid_->::Msg::Ident::Clear();
  clear_has_guid();
}
inline const ::Msg::Ident& TileNPC::guid() const {
  return guid_ != NULL ? *guid_ : *default_instance_->guid_;
}
inline ::Msg::Ident* TileNPC::mutable_guid() {
  set_has_guid();
  if (guid_ == NULL) guid_ = new ::Msg::Ident;
  return guid_;
}
inline ::Msg::Ident* TileNPC::release_guid() {
  clear_has_guid();
  ::Msg::Ident* temp = guid_;
  guid_ = NULL;
  return temp;
}
inline void TileNPC::set_allocated_guid(::Msg::Ident* guid) {
  delete guid_;
  guid_ = guid;
  if (guid) {
    set_has_guid();
  } else {
    clear_has_guid();
  }
}

// -------------------------------------------------------------------

// AckMiningTitle

// repeated .Msg.TileState tile = 1;
inline int AckMiningTitle::tile_size() const {
  return tile_.size();
}
inline void AckMiningTitle::clear_tile() {
  tile_.Clear();
}
inline const ::Msg::TileState& AckMiningTitle::tile(int index) const {
  return tile_.Get(index);
}
inline ::Msg::TileState* AckMiningTitle::mutable_tile(int index) {
  return tile_.Mutable(index);
}
inline ::Msg::TileState* AckMiningTitle::add_tile() {
  return tile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileState >&
AckMiningTitle::tile() const {
  return tile_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::TileState >*
AckMiningTitle::mutable_tile() {
  return &tile_;
}

// repeated .Msg.TileBuilding building = 2;
inline int AckMiningTitle::building_size() const {
  return building_.size();
}
inline void AckMiningTitle::clear_building() {
  building_.Clear();
}
inline const ::Msg::TileBuilding& AckMiningTitle::building(int index) const {
  return building_.Get(index);
}
inline ::Msg::TileBuilding* AckMiningTitle::mutable_building(int index) {
  return building_.Mutable(index);
}
inline ::Msg::TileBuilding* AckMiningTitle::add_building() {
  return building_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileBuilding >&
AckMiningTitle::building() const {
  return building_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::TileBuilding >*
AckMiningTitle::mutable_building() {
  return &building_;
}

// repeated .Msg.TileNPC npc = 3;
inline int AckMiningTitle::npc_size() const {
  return npc_.size();
}
inline void AckMiningTitle::clear_npc() {
  npc_.Clear();
}
inline const ::Msg::TileNPC& AckMiningTitle::npc(int index) const {
  return npc_.Get(index);
}
inline ::Msg::TileNPC* AckMiningTitle::mutable_npc(int index) {
  return npc_.Mutable(index);
}
inline ::Msg::TileNPC* AckMiningTitle::add_npc() {
  return npc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::TileNPC >&
AckMiningTitle::npc() const {
  return npc_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::TileNPC >*
AckMiningTitle::mutable_npc() {
  return &npc_;
}

// -------------------------------------------------------------------

// ReqSearchOppnent

// -------------------------------------------------------------------

// AckSearchOppnent

// required int32 scene_id = 1;
inline bool AckSearchOppnent::has_scene_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSearchOppnent::set_has_scene_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSearchOppnent::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSearchOppnent::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 AckSearchOppnent::scene_id() const {
  return scene_id_;
}
inline void AckSearchOppnent::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// -------------------------------------------------------------------

// ReqSendMail

// required .Msg.Ident reciever = 1;
inline bool ReqSendMail::has_reciever() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSendMail::set_has_reciever() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSendMail::clear_has_reciever() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSendMail::clear_reciever() {
  if (reciever_ != NULL) reciever_->::Msg::Ident::Clear();
  clear_has_reciever();
}
inline const ::Msg::Ident& ReqSendMail::reciever() const {
  return reciever_ != NULL ? *reciever_ : *default_instance_->reciever_;
}
inline ::Msg::Ident* ReqSendMail::mutable_reciever() {
  set_has_reciever();
  if (reciever_ == NULL) reciever_ = new ::Msg::Ident;
  return reciever_;
}
inline ::Msg::Ident* ReqSendMail::release_reciever() {
  clear_has_reciever();
  ::Msg::Ident* temp = reciever_;
  reciever_ = NULL;
  return temp;
}
inline void ReqSendMail::set_allocated_reciever(::Msg::Ident* reciever) {
  delete reciever_;
  reciever_ = reciever;
  if (reciever) {
    set_has_reciever();
  } else {
    clear_has_reciever();
  }
}

// repeated .Msg.ItemStruct item_list = 2;
inline int ReqSendMail::item_list_size() const {
  return item_list_.size();
}
inline void ReqSendMail::clear_item_list() {
  item_list_.Clear();
}
inline const ::Msg::ItemStruct& ReqSendMail::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Msg::ItemStruct* ReqSendMail::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Msg::ItemStruct* ReqSendMail::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >&
ReqSendMail::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::ItemStruct >*
ReqSendMail::mutable_item_list() {
  return &item_list_;
}

// repeated .Msg.CurrencyStruct currency_list = 3;
inline int ReqSendMail::currency_list_size() const {
  return currency_list_.size();
}
inline void ReqSendMail::clear_currency_list() {
  currency_list_.Clear();
}
inline const ::Msg::CurrencyStruct& ReqSendMail::currency_list(int index) const {
  return currency_list_.Get(index);
}
inline ::Msg::CurrencyStruct* ReqSendMail::mutable_currency_list(int index) {
  return currency_list_.Mutable(index);
}
inline ::Msg::CurrencyStruct* ReqSendMail::add_currency_list() {
  return currency_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::CurrencyStruct >&
ReqSendMail::currency_list() const {
  return currency_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::CurrencyStruct >*
ReqSendMail::mutable_currency_list() {
  return &currency_list_;
}

// -------------------------------------------------------------------

// ReqSwitchServer

// required .Msg.Ident selfid = 1;
inline bool ReqSwitchServer::has_selfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSwitchServer::set_has_selfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSwitchServer::clear_has_selfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSwitchServer::clear_selfid() {
  if (selfid_ != NULL) selfid_->::Msg::Ident::Clear();
  clear_has_selfid();
}
inline const ::Msg::Ident& ReqSwitchServer::selfid() const {
  return selfid_ != NULL ? *selfid_ : *default_instance_->selfid_;
}
inline ::Msg::Ident* ReqSwitchServer::mutable_selfid() {
  set_has_selfid();
  if (selfid_ == NULL) selfid_ = new ::Msg::Ident;
  return selfid_;
}
inline ::Msg::Ident* ReqSwitchServer::release_selfid() {
  clear_has_selfid();
  ::Msg::Ident* temp = selfid_;
  selfid_ = NULL;
  return temp;
}
inline void ReqSwitchServer::set_allocated_selfid(::Msg::Ident* selfid) {
  delete selfid_;
  selfid_ = selfid;
  if (selfid) {
    set_has_selfid();
  } else {
    clear_has_selfid();
  }
}

// required int64 self_serverid = 2;
inline bool ReqSwitchServer::has_self_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSwitchServer::set_has_self_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSwitchServer::clear_has_self_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSwitchServer::clear_self_serverid() {
  self_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_self_serverid();
}
inline ::google::protobuf::int64 ReqSwitchServer::self_serverid() const {
  return self_serverid_;
}
inline void ReqSwitchServer::set_self_serverid(::google::protobuf::int64 value) {
  set_has_self_serverid();
  self_serverid_ = value;
}

// required int64 target_serverid = 3;
inline bool ReqSwitchServer::has_target_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqSwitchServer::set_has_target_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqSwitchServer::clear_has_target_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqSwitchServer::clear_target_serverid() {
  target_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_target_serverid();
}
inline ::google::protobuf::int64 ReqSwitchServer::target_serverid() const {
  return target_serverid_;
}
inline void ReqSwitchServer::set_target_serverid(::google::protobuf::int64 value) {
  set_has_target_serverid();
  target_serverid_ = value;
}

// required int64 gate_serverid = 4;
inline bool ReqSwitchServer::has_gate_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqSwitchServer::set_has_gate_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqSwitchServer::clear_has_gate_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqSwitchServer::clear_gate_serverid() {
  gate_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_gate_serverid();
}
inline ::google::protobuf::int64 ReqSwitchServer::gate_serverid() const {
  return gate_serverid_;
}
inline void ReqSwitchServer::set_gate_serverid(::google::protobuf::int64 value) {
  set_has_gate_serverid();
  gate_serverid_ = value;
}

// required int64 SceneID = 5;
inline bool ReqSwitchServer::has_sceneid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqSwitchServer::set_has_sceneid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqSwitchServer::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqSwitchServer::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(0);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 ReqSwitchServer::sceneid() const {
  return sceneid_;
}
inline void ReqSwitchServer::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// required .Msg.Ident client_id = 6;
inline bool ReqSwitchServer::has_client_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqSwitchServer::set_has_client_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqSwitchServer::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqSwitchServer::clear_client_id() {
  if (client_id_ != NULL) client_id_->::Msg::Ident::Clear();
  clear_has_client_id();
}
inline const ::Msg::Ident& ReqSwitchServer::client_id() const {
  return client_id_ != NULL ? *client_id_ : *default_instance_->client_id_;
}
inline ::Msg::Ident* ReqSwitchServer::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == NULL) client_id_ = new ::Msg::Ident;
  return client_id_;
}
inline ::Msg::Ident* ReqSwitchServer::release_client_id() {
  clear_has_client_id();
  ::Msg::Ident* temp = client_id_;
  client_id_ = NULL;
  return temp;
}
inline void ReqSwitchServer::set_allocated_client_id(::Msg::Ident* client_id) {
  delete client_id_;
  client_id_ = client_id;
  if (client_id) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
}

// required int64 groupID = 7;
inline bool ReqSwitchServer::has_groupid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqSwitchServer::set_has_groupid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqSwitchServer::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqSwitchServer::clear_groupid() {
  groupid_ = GOOGLE_LONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::int64 ReqSwitchServer::groupid() const {
  return groupid_;
}
inline void ReqSwitchServer::set_groupid(::google::protobuf::int64 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// AckSwitchServer

// required .Msg.Ident selfid = 1;
inline bool AckSwitchServer::has_selfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSwitchServer::set_has_selfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSwitchServer::clear_has_selfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSwitchServer::clear_selfid() {
  if (selfid_ != NULL) selfid_->::Msg::Ident::Clear();
  clear_has_selfid();
}
inline const ::Msg::Ident& AckSwitchServer::selfid() const {
  return selfid_ != NULL ? *selfid_ : *default_instance_->selfid_;
}
inline ::Msg::Ident* AckSwitchServer::mutable_selfid() {
  set_has_selfid();
  if (selfid_ == NULL) selfid_ = new ::Msg::Ident;
  return selfid_;
}
inline ::Msg::Ident* AckSwitchServer::release_selfid() {
  clear_has_selfid();
  ::Msg::Ident* temp = selfid_;
  selfid_ = NULL;
  return temp;
}
inline void AckSwitchServer::set_allocated_selfid(::Msg::Ident* selfid) {
  delete selfid_;
  selfid_ = selfid;
  if (selfid) {
    set_has_selfid();
  } else {
    clear_has_selfid();
  }
}

// required int64 self_serverid = 2;
inline bool AckSwitchServer::has_self_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSwitchServer::set_has_self_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSwitchServer::clear_has_self_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSwitchServer::clear_self_serverid() {
  self_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_self_serverid();
}
inline ::google::protobuf::int64 AckSwitchServer::self_serverid() const {
  return self_serverid_;
}
inline void AckSwitchServer::set_self_serverid(::google::protobuf::int64 value) {
  set_has_self_serverid();
  self_serverid_ = value;
}

// required int64 target_serverid = 3;
inline bool AckSwitchServer::has_target_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckSwitchServer::set_has_target_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckSwitchServer::clear_has_target_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckSwitchServer::clear_target_serverid() {
  target_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_target_serverid();
}
inline ::google::protobuf::int64 AckSwitchServer::target_serverid() const {
  return target_serverid_;
}
inline void AckSwitchServer::set_target_serverid(::google::protobuf::int64 value) {
  set_has_target_serverid();
  target_serverid_ = value;
}

// required int64 gate_serverid = 4;
inline bool AckSwitchServer::has_gate_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckSwitchServer::set_has_gate_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckSwitchServer::clear_has_gate_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckSwitchServer::clear_gate_serverid() {
  gate_serverid_ = GOOGLE_LONGLONG(0);
  clear_has_gate_serverid();
}
inline ::google::protobuf::int64 AckSwitchServer::gate_serverid() const {
  return gate_serverid_;
}
inline void AckSwitchServer::set_gate_serverid(::google::protobuf::int64 value) {
  set_has_gate_serverid();
  gate_serverid_ = value;
}

// -------------------------------------------------------------------

// TeamIo

// required .Msg.Ident team_id = 1;
inline bool TeamIo::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamIo::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamIo::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamIo::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& TeamIo::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* TeamIo::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* TeamIo::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void TeamIo::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// required .Msg.Ident captain_id = 2;
inline bool TeamIo::has_captain_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamIo::set_has_captain_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamIo::clear_has_captain_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamIo::clear_captain_id() {
  if (captain_id_ != NULL) captain_id_->::Msg::Ident::Clear();
  clear_has_captain_id();
}
inline const ::Msg::Ident& TeamIo::captain_id() const {
  return captain_id_ != NULL ? *captain_id_ : *default_instance_->captain_id_;
}
inline ::Msg::Ident* TeamIo::mutable_captain_id() {
  set_has_captain_id();
  if (captain_id_ == NULL) captain_id_ = new ::Msg::Ident;
  return captain_id_;
}
inline ::Msg::Ident* TeamIo::release_captain_id() {
  clear_has_captain_id();
  ::Msg::Ident* temp = captain_id_;
  captain_id_ = NULL;
  return temp;
}
inline void TeamIo::set_allocated_captain_id(::Msg::Ident* captain_id) {
  delete captain_id_;
  captain_id_ = captain_id;
  if (captain_id) {
    set_has_captain_id();
  } else {
    clear_has_captain_id();
  }
}

// repeated .Msg.TeammemberIo teammemberIo = 3;
inline int TeamIo::teammemberio_size() const {
  return teammemberio_.size();
}
inline void TeamIo::clear_teammemberio() {
  teammemberio_.Clear();
}
inline const ::Msg::TeammemberIo& TeamIo::teammemberio(int index) const {
  return teammemberio_.Get(index);
}
inline ::Msg::TeammemberIo* TeamIo::mutable_teammemberio(int index) {
  return teammemberio_.Mutable(index);
}
inline ::Msg::TeammemberIo* TeamIo::add_teammemberio() {
  return teammemberio_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::TeammemberIo >&
TeamIo::teammemberio() const {
  return teammemberio_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::TeammemberIo >*
TeamIo::mutable_teammemberio() {
  return &teammemberio_;
}

// -------------------------------------------------------------------

// TeammemberIo

// required .Msg.Ident player_id = 1;
inline bool TeammemberIo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeammemberIo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeammemberIo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeammemberIo::clear_player_id() {
  if (player_id_ != NULL) player_id_->::Msg::Ident::Clear();
  clear_has_player_id();
}
inline const ::Msg::Ident& TeammemberIo::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::Msg::Ident* TeammemberIo::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::Msg::Ident;
  return player_id_;
}
inline ::Msg::Ident* TeammemberIo::release_player_id() {
  clear_has_player_id();
  ::Msg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void TeammemberIo::set_allocated_player_id(::Msg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required string name = 2;
inline bool TeammemberIo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeammemberIo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeammemberIo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeammemberIo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TeammemberIo::name() const {
  return *name_;
}
inline void TeammemberIo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TeammemberIo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TeammemberIo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeammemberIo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TeammemberIo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeammemberIo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 nLevel = 3;
inline bool TeammemberIo::has_nlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeammemberIo::set_has_nlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeammemberIo::clear_has_nlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeammemberIo::clear_nlevel() {
  nlevel_ = 0;
  clear_has_nlevel();
}
inline ::google::protobuf::int32 TeammemberIo::nlevel() const {
  return nlevel_;
}
inline void TeammemberIo::set_nlevel(::google::protobuf::int32 value) {
  set_has_nlevel();
  nlevel_ = value;
}

// required int32 job = 4;
inline bool TeammemberIo::has_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeammemberIo::set_has_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeammemberIo::clear_has_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeammemberIo::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 TeammemberIo::job() const {
  return job_;
}
inline void TeammemberIo::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// required string HeadIcon = 5;
inline bool TeammemberIo::has_headicon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeammemberIo::set_has_headicon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeammemberIo::clear_has_headicon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeammemberIo::clear_headicon() {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    headicon_->clear();
  }
  clear_has_headicon();
}
inline const ::std::string& TeammemberIo::headicon() const {
  return *headicon_;
}
inline void TeammemberIo::set_headicon(const ::std::string& value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void TeammemberIo::set_headicon(const char* value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void TeammemberIo::set_headicon(const char* value, size_t size) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeammemberIo::mutable_headicon() {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  return headicon_;
}
inline ::std::string* TeammemberIo::release_headicon() {
  clear_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headicon_;
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeammemberIo::set_allocated_headicon(::std::string* headicon) {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    delete headicon_;
  }
  if (headicon) {
    set_has_headicon();
    headicon_ = headicon;
  } else {
    clear_has_headicon();
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqAckCreateTeam

// required .Msg.Ident team_id = 1;
inline bool ReqAckCreateTeam::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckCreateTeam::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckCreateTeam::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckCreateTeam::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqAckCreateTeam::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqAckCreateTeam::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqAckCreateTeam::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqAckCreateTeam::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// optional .Msg.TeamIo xTeamIo = 2;
inline bool ReqAckCreateTeam::has_xteamio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckCreateTeam::set_has_xteamio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckCreateTeam::clear_has_xteamio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckCreateTeam::clear_xteamio() {
  if (xteamio_ != NULL) xteamio_->::Msg::TeamIo::Clear();
  clear_has_xteamio();
}
inline const ::Msg::TeamIo& ReqAckCreateTeam::xteamio() const {
  return xteamio_ != NULL ? *xteamio_ : *default_instance_->xteamio_;
}
inline ::Msg::TeamIo* ReqAckCreateTeam::mutable_xteamio() {
  set_has_xteamio();
  if (xteamio_ == NULL) xteamio_ = new ::Msg::TeamIo;
  return xteamio_;
}
inline ::Msg::TeamIo* ReqAckCreateTeam::release_xteamio() {
  clear_has_xteamio();
  ::Msg::TeamIo* temp = xteamio_;
  xteamio_ = NULL;
  return temp;
}
inline void ReqAckCreateTeam::set_allocated_xteamio(::Msg::TeamIo* xteamio) {
  delete xteamio_;
  xteamio_ = xteamio;
  if (xteamio) {
    set_has_xteamio();
  } else {
    clear_has_xteamio();
  }
}

// -------------------------------------------------------------------

// ReqAckJoinTeam

// required .Msg.Ident team_id = 1;
inline bool ReqAckJoinTeam::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckJoinTeam::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckJoinTeam::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckJoinTeam::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqAckJoinTeam::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqAckJoinTeam::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqAckJoinTeam::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqAckJoinTeam::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// optional .Msg.TeamIo xTeamIo = 2;
inline bool ReqAckJoinTeam::has_xteamio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckJoinTeam::set_has_xteamio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckJoinTeam::clear_has_xteamio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckJoinTeam::clear_xteamio() {
  if (xteamio_ != NULL) xteamio_->::Msg::TeamIo::Clear();
  clear_has_xteamio();
}
inline const ::Msg::TeamIo& ReqAckJoinTeam::xteamio() const {
  return xteamio_ != NULL ? *xteamio_ : *default_instance_->xteamio_;
}
inline ::Msg::TeamIo* ReqAckJoinTeam::mutable_xteamio() {
  set_has_xteamio();
  if (xteamio_ == NULL) xteamio_ = new ::Msg::TeamIo;
  return xteamio_;
}
inline ::Msg::TeamIo* ReqAckJoinTeam::release_xteamio() {
  clear_has_xteamio();
  ::Msg::TeamIo* temp = xteamio_;
  xteamio_ = NULL;
  return temp;
}
inline void ReqAckJoinTeam::set_allocated_xteamio(::Msg::TeamIo* xteamio) {
  delete xteamio_;
  xteamio_ = xteamio;
  if (xteamio) {
    set_has_xteamio();
  } else {
    clear_has_xteamio();
  }
}

// -------------------------------------------------------------------

// ReqAckLeaveTeam

// required .Msg.Ident team_id = 1;
inline bool ReqAckLeaveTeam::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckLeaveTeam::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckLeaveTeam::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckLeaveTeam::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqAckLeaveTeam::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqAckLeaveTeam::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqAckLeaveTeam::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqAckLeaveTeam::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// optional .Msg.TeamIo xTeamIo = 2;
inline bool ReqAckLeaveTeam::has_xteamio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckLeaveTeam::set_has_xteamio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckLeaveTeam::clear_has_xteamio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckLeaveTeam::clear_xteamio() {
  if (xteamio_ != NULL) xteamio_->::Msg::TeamIo::Clear();
  clear_has_xteamio();
}
inline const ::Msg::TeamIo& ReqAckLeaveTeam::xteamio() const {
  return xteamio_ != NULL ? *xteamio_ : *default_instance_->xteamio_;
}
inline ::Msg::TeamIo* ReqAckLeaveTeam::mutable_xteamio() {
  set_has_xteamio();
  if (xteamio_ == NULL) xteamio_ = new ::Msg::TeamIo;
  return xteamio_;
}
inline ::Msg::TeamIo* ReqAckLeaveTeam::release_xteamio() {
  clear_has_xteamio();
  ::Msg::TeamIo* temp = xteamio_;
  xteamio_ = NULL;
  return temp;
}
inline void ReqAckLeaveTeam::set_allocated_xteamio(::Msg::TeamIo* xteamio) {
  delete xteamio_;
  xteamio_ = xteamio;
  if (xteamio) {
    set_has_xteamio();
  } else {
    clear_has_xteamio();
  }
}

// -------------------------------------------------------------------

// ReqAckOprTeamMember

// required .Msg.Ident team_id = 1;
inline bool ReqAckOprTeamMember::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckOprTeamMember::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckOprTeamMember::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckOprTeamMember::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqAckOprTeamMember::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqAckOprTeamMember::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqAckOprTeamMember::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqAckOprTeamMember::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// required .Msg.Ident member_id = 2;
inline bool ReqAckOprTeamMember::has_member_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckOprTeamMember::set_has_member_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckOprTeamMember::clear_has_member_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckOprTeamMember::clear_member_id() {
  if (member_id_ != NULL) member_id_->::Msg::Ident::Clear();
  clear_has_member_id();
}
inline const ::Msg::Ident& ReqAckOprTeamMember::member_id() const {
  return member_id_ != NULL ? *member_id_ : *default_instance_->member_id_;
}
inline ::Msg::Ident* ReqAckOprTeamMember::mutable_member_id() {
  set_has_member_id();
  if (member_id_ == NULL) member_id_ = new ::Msg::Ident;
  return member_id_;
}
inline ::Msg::Ident* ReqAckOprTeamMember::release_member_id() {
  clear_has_member_id();
  ::Msg::Ident* temp = member_id_;
  member_id_ = NULL;
  return temp;
}
inline void ReqAckOprTeamMember::set_allocated_member_id(::Msg::Ident* member_id) {
  delete member_id_;
  member_id_ = member_id;
  if (member_id) {
    set_has_member_id();
  } else {
    clear_has_member_id();
  }
}

// required .Msg.ReqAckOprTeamMember.EGTeamMemberOprType type = 3;
inline bool ReqAckOprTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckOprTeamMember::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckOprTeamMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckOprTeamMember::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Msg::ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember::type() const {
  return static_cast< ::Msg::ReqAckOprTeamMember_EGTeamMemberOprType >(type_);
}
inline void ReqAckOprTeamMember::set_type(::Msg::ReqAckOprTeamMember_EGTeamMemberOprType value) {
  assert(::Msg::ReqAckOprTeamMember_EGTeamMemberOprType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Msg.TeamIo xTeamIo = 4;
inline bool ReqAckOprTeamMember::has_xteamio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqAckOprTeamMember::set_has_xteamio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqAckOprTeamMember::clear_has_xteamio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqAckOprTeamMember::clear_xteamio() {
  if (xteamio_ != NULL) xteamio_->::Msg::TeamIo::Clear();
  clear_has_xteamio();
}
inline const ::Msg::TeamIo& ReqAckOprTeamMember::xteamio() const {
  return xteamio_ != NULL ? *xteamio_ : *default_instance_->xteamio_;
}
inline ::Msg::TeamIo* ReqAckOprTeamMember::mutable_xteamio() {
  set_has_xteamio();
  if (xteamio_ == NULL) xteamio_ = new ::Msg::TeamIo;
  return xteamio_;
}
inline ::Msg::TeamIo* ReqAckOprTeamMember::release_xteamio() {
  clear_has_xteamio();
  ::Msg::TeamIo* temp = xteamio_;
  xteamio_ = NULL;
  return temp;
}
inline void ReqAckOprTeamMember::set_allocated_xteamio(::Msg::TeamIo* xteamio) {
  delete xteamio_;
  xteamio_ = xteamio;
  if (xteamio) {
    set_has_xteamio();
  } else {
    clear_has_xteamio();
  }
}

// -------------------------------------------------------------------

// ReqAckInviteTeam

// required .Msg.Ident team_id = 1;
inline bool ReqAckInviteTeam::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAckInviteTeam::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAckInviteTeam::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAckInviteTeam::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqAckInviteTeam::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqAckInviteTeam::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// required .Msg.Ident self_id = 2;
inline bool ReqAckInviteTeam::has_self_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAckInviteTeam::set_has_self_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAckInviteTeam::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAckInviteTeam::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& ReqAckInviteTeam::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void ReqAckInviteTeam::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// required .Msg.Ident invite_target_id = 3;
inline bool ReqAckInviteTeam::has_invite_target_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqAckInviteTeam::set_has_invite_target_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqAckInviteTeam::clear_has_invite_target_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqAckInviteTeam::clear_invite_target_id() {
  if (invite_target_id_ != NULL) invite_target_id_->::Msg::Ident::Clear();
  clear_has_invite_target_id();
}
inline const ::Msg::Ident& ReqAckInviteTeam::invite_target_id() const {
  return invite_target_id_ != NULL ? *invite_target_id_ : *default_instance_->invite_target_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::mutable_invite_target_id() {
  set_has_invite_target_id();
  if (invite_target_id_ == NULL) invite_target_id_ = new ::Msg::Ident;
  return invite_target_id_;
}
inline ::Msg::Ident* ReqAckInviteTeam::release_invite_target_id() {
  clear_has_invite_target_id();
  ::Msg::Ident* temp = invite_target_id_;
  invite_target_id_ = NULL;
  return temp;
}
inline void ReqAckInviteTeam::set_allocated_invite_target_id(::Msg::Ident* invite_target_id) {
  delete invite_target_id_;
  invite_target_id_ = invite_target_id;
  if (invite_target_id) {
    set_has_invite_target_id();
  } else {
    clear_has_invite_target_id();
  }
}

// -------------------------------------------------------------------

// ReqTeamEnterEctype

// required .Msg.Ident team_id = 1;
inline bool ReqTeamEnterEctype::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTeamEnterEctype::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTeamEnterEctype::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTeamEnterEctype::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqTeamEnterEctype::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqTeamEnterEctype::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqTeamEnterEctype::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqTeamEnterEctype::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// required .Msg.Ident self_id = 2;
inline bool ReqTeamEnterEctype::has_self_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqTeamEnterEctype::set_has_self_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqTeamEnterEctype::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqTeamEnterEctype::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& ReqTeamEnterEctype::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* ReqTeamEnterEctype::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* ReqTeamEnterEctype::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void ReqTeamEnterEctype::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// optional int32 nEctypeID = 3;
inline bool ReqTeamEnterEctype::has_nectypeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqTeamEnterEctype::set_has_nectypeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqTeamEnterEctype::clear_has_nectypeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqTeamEnterEctype::clear_nectypeid() {
  nectypeid_ = 0;
  clear_has_nectypeid();
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nectypeid() const {
  return nectypeid_;
}
inline void ReqTeamEnterEctype::set_nectypeid(::google::protobuf::int32 value) {
  set_has_nectypeid();
  nectypeid_ = value;
}

// optional int32 nGroupID = 4;
inline bool ReqTeamEnterEctype::has_ngroupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqTeamEnterEctype::set_has_ngroupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqTeamEnterEctype::clear_has_ngroupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqTeamEnterEctype::clear_ngroupid() {
  ngroupid_ = 0;
  clear_has_ngroupid();
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::ngroupid() const {
  return ngroupid_;
}
inline void ReqTeamEnterEctype::set_ngroupid(::google::protobuf::int32 value) {
  set_has_ngroupid();
  ngroupid_ = value;
}

// optional int32 nResult = 5;
inline bool ReqTeamEnterEctype::has_nresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqTeamEnterEctype::set_has_nresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqTeamEnterEctype::clear_has_nresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqTeamEnterEctype::clear_nresult() {
  nresult_ = 0;
  clear_has_nresult();
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nresult() const {
  return nresult_;
}
inline void ReqTeamEnterEctype::set_nresult(::google::protobuf::int32 value) {
  set_has_nresult();
  nresult_ = value;
}

// optional int32 nServerID = 6;
inline bool ReqTeamEnterEctype::has_nserverid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqTeamEnterEctype::set_has_nserverid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqTeamEnterEctype::clear_has_nserverid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqTeamEnterEctype::clear_nserverid() {
  nserverid_ = 0;
  clear_has_nserverid();
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nserverid() const {
  return nserverid_;
}
inline void ReqTeamEnterEctype::set_nserverid(::google::protobuf::int32 value) {
  set_has_nserverid();
  nserverid_ = value;
}

// -------------------------------------------------------------------

// AckTeamEnterEctype

// required .Msg.Ident team_id = 1;
inline bool AckTeamEnterEctype::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckTeamEnterEctype::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckTeamEnterEctype::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckTeamEnterEctype::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& AckTeamEnterEctype::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* AckTeamEnterEctype::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* AckTeamEnterEctype::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void AckTeamEnterEctype::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// required .Msg.Ident self_id = 2;
inline bool AckTeamEnterEctype::has_self_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckTeamEnterEctype::set_has_self_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckTeamEnterEctype::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckTeamEnterEctype::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& AckTeamEnterEctype::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* AckTeamEnterEctype::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* AckTeamEnterEctype::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void AckTeamEnterEctype::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// optional int32 nEctypeID = 3;
inline bool AckTeamEnterEctype::has_nectypeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckTeamEnterEctype::set_has_nectypeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckTeamEnterEctype::clear_has_nectypeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckTeamEnterEctype::clear_nectypeid() {
  nectypeid_ = 0;
  clear_has_nectypeid();
}
inline ::google::protobuf::int32 AckTeamEnterEctype::nectypeid() const {
  return nectypeid_;
}
inline void AckTeamEnterEctype::set_nectypeid(::google::protobuf::int32 value) {
  set_has_nectypeid();
  nectypeid_ = value;
}

// optional int32 nGroupID = 4;
inline bool AckTeamEnterEctype::has_ngroupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckTeamEnterEctype::set_has_ngroupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckTeamEnterEctype::clear_has_ngroupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckTeamEnterEctype::clear_ngroupid() {
  ngroupid_ = 0;
  clear_has_ngroupid();
}
inline ::google::protobuf::int32 AckTeamEnterEctype::ngroupid() const {
  return ngroupid_;
}
inline void AckTeamEnterEctype::set_ngroupid(::google::protobuf::int32 value) {
  set_has_ngroupid();
  ngroupid_ = value;
}

// optional int32 nResult = 5;
inline bool AckTeamEnterEctype::has_nresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckTeamEnterEctype::set_has_nresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckTeamEnterEctype::clear_has_nresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckTeamEnterEctype::clear_nresult() {
  nresult_ = 0;
  clear_has_nresult();
}
inline ::google::protobuf::int32 AckTeamEnterEctype::nresult() const {
  return nresult_;
}
inline void AckTeamEnterEctype::set_nresult(::google::protobuf::int32 value) {
  set_has_nresult();
  nresult_ = value;
}

// -------------------------------------------------------------------

// GridGuildBaseIo

// required .Msg.Ident id = 1;
inline bool GridGuildBaseIo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GridGuildBaseIo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GridGuildBaseIo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GridGuildBaseIo::clear_id() {
  if (id_ != NULL) id_->::Msg::Ident::Clear();
  clear_has_id();
}
inline const ::Msg::Ident& GridGuildBaseIo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Msg::Ident* GridGuildBaseIo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Msg::Ident;
  return id_;
}
inline ::Msg::Ident* GridGuildBaseIo::release_id() {
  clear_has_id();
  ::Msg::Ident* temp = id_;
  id_ = NULL;
  return temp;
}
inline void GridGuildBaseIo::set_allocated_id(::Msg::Ident* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required int32 level = 2;
inline bool GridGuildBaseIo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GridGuildBaseIo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GridGuildBaseIo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GridGuildBaseIo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GridGuildBaseIo::level() const {
  return level_;
}
inline void GridGuildBaseIo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 count = 3;
inline bool GridGuildBaseIo::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GridGuildBaseIo::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GridGuildBaseIo::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GridGuildBaseIo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GridGuildBaseIo::count() const {
  return count_;
}
inline void GridGuildBaseIo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 resource = 4;
inline bool GridGuildBaseIo::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GridGuildBaseIo::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GridGuildBaseIo::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GridGuildBaseIo::clear_resource() {
  resource_ = 0;
  clear_has_resource();
}
inline ::google::protobuf::int32 GridGuildBaseIo::resource() const {
  return resource_;
}
inline void GridGuildBaseIo::set_resource(::google::protobuf::int32 value) {
  set_has_resource();
  resource_ = value;
}

// required bytes icon = 5;
inline bool GridGuildBaseIo::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GridGuildBaseIo::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GridGuildBaseIo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GridGuildBaseIo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& GridGuildBaseIo::icon() const {
  return *icon_;
}
inline void GridGuildBaseIo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GridGuildBaseIo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GridGuildBaseIo::set_icon(const void* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GridGuildBaseIo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* GridGuildBaseIo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GridGuildBaseIo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqBigMapGridIo

// repeated bytes map_title_id = 1;
inline int ReqBigMapGridIo::map_title_id_size() const {
  return map_title_id_.size();
}
inline void ReqBigMapGridIo::clear_map_title_id() {
  map_title_id_.Clear();
}
inline const ::std::string& ReqBigMapGridIo::map_title_id(int index) const {
  return map_title_id_.Get(index);
}
inline ::std::string* ReqBigMapGridIo::mutable_map_title_id(int index) {
  return map_title_id_.Mutable(index);
}
inline void ReqBigMapGridIo::set_map_title_id(int index, const ::std::string& value) {
  map_title_id_.Mutable(index)->assign(value);
}
inline void ReqBigMapGridIo::set_map_title_id(int index, const char* value) {
  map_title_id_.Mutable(index)->assign(value);
}
inline void ReqBigMapGridIo::set_map_title_id(int index, const void* value, size_t size) {
  map_title_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqBigMapGridIo::add_map_title_id() {
  return map_title_id_.Add();
}
inline void ReqBigMapGridIo::add_map_title_id(const ::std::string& value) {
  map_title_id_.Add()->assign(value);
}
inline void ReqBigMapGridIo::add_map_title_id(const char* value) {
  map_title_id_.Add()->assign(value);
}
inline void ReqBigMapGridIo::add_map_title_id(const void* value, size_t size) {
  map_title_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqBigMapGridIo::map_title_id() const {
  return map_title_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqBigMapGridIo::mutable_map_title_id() {
  return &map_title_id_;
}

// -------------------------------------------------------------------

// BigMapGridBaseIo

// required bytes id = 1;
inline bool BigMapGridBaseIo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapGridBaseIo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapGridBaseIo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapGridBaseIo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BigMapGridBaseIo::id() const {
  return *id_;
}
inline void BigMapGridBaseIo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BigMapGridBaseIo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BigMapGridBaseIo::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigMapGridBaseIo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BigMapGridBaseIo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BigMapGridBaseIo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.GridGuildBaseIo guild_io = 2;
inline bool BigMapGridBaseIo::has_guild_io() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapGridBaseIo::set_has_guild_io() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapGridBaseIo::clear_has_guild_io() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapGridBaseIo::clear_guild_io() {
  if (guild_io_ != NULL) guild_io_->::Msg::GridGuildBaseIo::Clear();
  clear_has_guild_io();
}
inline const ::Msg::GridGuildBaseIo& BigMapGridBaseIo::guild_io() const {
  return guild_io_ != NULL ? *guild_io_ : *default_instance_->guild_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapGridBaseIo::mutable_guild_io() {
  set_has_guild_io();
  if (guild_io_ == NULL) guild_io_ = new ::Msg::GridGuildBaseIo;
  return guild_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapGridBaseIo::release_guild_io() {
  clear_has_guild_io();
  ::Msg::GridGuildBaseIo* temp = guild_io_;
  guild_io_ = NULL;
  return temp;
}
inline void BigMapGridBaseIo::set_allocated_guild_io(::Msg::GridGuildBaseIo* guild_io) {
  delete guild_io_;
  guild_io_ = guild_io;
  if (guild_io) {
    set_has_guild_io();
  } else {
    clear_has_guild_io();
  }
}

// required int32 kingwar_time = 10;
inline bool BigMapGridBaseIo::has_kingwar_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapGridBaseIo::set_has_kingwar_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapGridBaseIo::clear_has_kingwar_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapGridBaseIo::clear_kingwar_time() {
  kingwar_time_ = 0;
  clear_has_kingwar_time();
}
inline ::google::protobuf::int32 BigMapGridBaseIo::kingwar_time() const {
  return kingwar_time_;
}
inline void BigMapGridBaseIo::set_kingwar_time(::google::protobuf::int32 value) {
  set_has_kingwar_time();
  kingwar_time_ = value;
}

// required .Msg.Ident kingwarrer = 11;
inline bool BigMapGridBaseIo::has_kingwarrer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigMapGridBaseIo::set_has_kingwarrer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigMapGridBaseIo::clear_has_kingwarrer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigMapGridBaseIo::clear_kingwarrer() {
  if (kingwarrer_ != NULL) kingwarrer_->::Msg::Ident::Clear();
  clear_has_kingwarrer();
}
inline const ::Msg::Ident& BigMapGridBaseIo::kingwarrer() const {
  return kingwarrer_ != NULL ? *kingwarrer_ : *default_instance_->kingwarrer_;
}
inline ::Msg::Ident* BigMapGridBaseIo::mutable_kingwarrer() {
  set_has_kingwarrer();
  if (kingwarrer_ == NULL) kingwarrer_ = new ::Msg::Ident;
  return kingwarrer_;
}
inline ::Msg::Ident* BigMapGridBaseIo::release_kingwarrer() {
  clear_has_kingwarrer();
  ::Msg::Ident* temp = kingwarrer_;
  kingwarrer_ = NULL;
  return temp;
}
inline void BigMapGridBaseIo::set_allocated_kingwarrer(::Msg::Ident* kingwarrer) {
  delete kingwarrer_;
  kingwarrer_ = kingwarrer;
  if (kingwarrer) {
    set_has_kingwarrer();
  } else {
    clear_has_kingwarrer();
  }
}

// required int32 hurting_time = 20;
inline bool BigMapGridBaseIo::has_hurting_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BigMapGridBaseIo::set_has_hurting_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BigMapGridBaseIo::clear_has_hurting_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BigMapGridBaseIo::clear_hurting_time() {
  hurting_time_ = 0;
  clear_has_hurting_time();
}
inline ::google::protobuf::int32 BigMapGridBaseIo::hurting_time() const {
  return hurting_time_;
}
inline void BigMapGridBaseIo::set_hurting_time(::google::protobuf::int32 value) {
  set_has_hurting_time();
  hurting_time_ = value;
}

// required .Msg.Ident hurter = 21;
inline bool BigMapGridBaseIo::has_hurter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BigMapGridBaseIo::set_has_hurter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BigMapGridBaseIo::clear_has_hurter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BigMapGridBaseIo::clear_hurter() {
  if (hurter_ != NULL) hurter_->::Msg::Ident::Clear();
  clear_has_hurter();
}
inline const ::Msg::Ident& BigMapGridBaseIo::hurter() const {
  return hurter_ != NULL ? *hurter_ : *default_instance_->hurter_;
}
inline ::Msg::Ident* BigMapGridBaseIo::mutable_hurter() {
  set_has_hurter();
  if (hurter_ == NULL) hurter_ = new ::Msg::Ident;
  return hurter_;
}
inline ::Msg::Ident* BigMapGridBaseIo::release_hurter() {
  clear_has_hurter();
  ::Msg::Ident* temp = hurter_;
  hurter_ = NULL;
  return temp;
}
inline void BigMapGridBaseIo::set_allocated_hurter(::Msg::Ident* hurter) {
  delete hurter_;
  hurter_ = hurter;
  if (hurter) {
    set_has_hurter();
  } else {
    clear_has_hurter();
  }
}

// -------------------------------------------------------------------

// BigMapLeaveMsg

// required .Msg.Ident owner = 1;
inline bool BigMapLeaveMsg::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapLeaveMsg::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapLeaveMsg::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapLeaveMsg::clear_owner() {
  if (owner_ != NULL) owner_->::Msg::Ident::Clear();
  clear_has_owner();
}
inline const ::Msg::Ident& BigMapLeaveMsg::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::Msg::Ident* BigMapLeaveMsg::mutable_owner() {
  set_has_owner();
  if (owner_ == NULL) owner_ = new ::Msg::Ident;
  return owner_;
}
inline ::Msg::Ident* BigMapLeaveMsg::release_owner() {
  clear_has_owner();
  ::Msg::Ident* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline void BigMapLeaveMsg::set_allocated_owner(::Msg::Ident* owner) {
  delete owner_;
  owner_ = owner;
  if (owner) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
}

// required bytes owner_name = 2;
inline bool BigMapLeaveMsg::has_owner_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapLeaveMsg::set_has_owner_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapLeaveMsg::clear_has_owner_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapLeaveMsg::clear_owner_name() {
  if (owner_name_ != &::google::protobuf::internal::kEmptyString) {
    owner_name_->clear();
  }
  clear_has_owner_name();
}
inline const ::std::string& BigMapLeaveMsg::owner_name() const {
  return *owner_name_;
}
inline void BigMapLeaveMsg::set_owner_name(const ::std::string& value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
}
inline void BigMapLeaveMsg::set_owner_name(const char* value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
}
inline void BigMapLeaveMsg::set_owner_name(const void* value, size_t size) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigMapLeaveMsg::mutable_owner_name() {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_name_ = new ::std::string;
  }
  return owner_name_;
}
inline ::std::string* BigMapLeaveMsg::release_owner_name() {
  clear_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_name_;
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BigMapLeaveMsg::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_name_;
  }
  if (owner_name) {
    set_has_owner_name();
    owner_name_ = owner_name;
  } else {
    clear_has_owner_name();
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes msg_data = 3;
inline bool BigMapLeaveMsg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapLeaveMsg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapLeaveMsg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapLeaveMsg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& BigMapLeaveMsg::msg_data() const {
  return *msg_data_;
}
inline void BigMapLeaveMsg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void BigMapLeaveMsg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void BigMapLeaveMsg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BigMapLeaveMsg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* BigMapLeaveMsg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BigMapLeaveMsg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 msg_time = 4;
inline bool BigMapLeaveMsg::has_msg_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigMapLeaveMsg::set_has_msg_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigMapLeaveMsg::clear_has_msg_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigMapLeaveMsg::clear_msg_time() {
  msg_time_ = 0;
  clear_has_msg_time();
}
inline ::google::protobuf::int32 BigMapLeaveMsg::msg_time() const {
  return msg_time_;
}
inline void BigMapLeaveMsg::set_msg_time(::google::protobuf::int32 value) {
  set_has_msg_time();
  msg_time_ = value;
}

// required int32 owner_level = 5;
inline bool BigMapLeaveMsg::has_owner_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BigMapLeaveMsg::set_has_owner_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BigMapLeaveMsg::clear_has_owner_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BigMapLeaveMsg::clear_owner_level() {
  owner_level_ = 0;
  clear_has_owner_level();
}
inline ::google::protobuf::int32 BigMapLeaveMsg::owner_level() const {
  return owner_level_;
}
inline void BigMapLeaveMsg::set_owner_level(::google::protobuf::int32 value) {
  set_has_owner_level();
  owner_level_ = value;
}

// -------------------------------------------------------------------

// BigMapWarHistory

// required .Msg.GridGuildBaseIo red_io = 1;
inline bool BigMapWarHistory::has_red_io() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapWarHistory::set_has_red_io() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapWarHistory::clear_has_red_io() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapWarHistory::clear_red_io() {
  if (red_io_ != NULL) red_io_->::Msg::GridGuildBaseIo::Clear();
  clear_has_red_io();
}
inline const ::Msg::GridGuildBaseIo& BigMapWarHistory::red_io() const {
  return red_io_ != NULL ? *red_io_ : *default_instance_->red_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapWarHistory::mutable_red_io() {
  set_has_red_io();
  if (red_io_ == NULL) red_io_ = new ::Msg::GridGuildBaseIo;
  return red_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapWarHistory::release_red_io() {
  clear_has_red_io();
  ::Msg::GridGuildBaseIo* temp = red_io_;
  red_io_ = NULL;
  return temp;
}
inline void BigMapWarHistory::set_allocated_red_io(::Msg::GridGuildBaseIo* red_io) {
  delete red_io_;
  red_io_ = red_io;
  if (red_io) {
    set_has_red_io();
  } else {
    clear_has_red_io();
  }
}

// required .Msg.GridGuildBaseIo blue_io = 2;
inline bool BigMapWarHistory::has_blue_io() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapWarHistory::set_has_blue_io() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapWarHistory::clear_has_blue_io() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapWarHistory::clear_blue_io() {
  if (blue_io_ != NULL) blue_io_->::Msg::GridGuildBaseIo::Clear();
  clear_has_blue_io();
}
inline const ::Msg::GridGuildBaseIo& BigMapWarHistory::blue_io() const {
  return blue_io_ != NULL ? *blue_io_ : *default_instance_->blue_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapWarHistory::mutable_blue_io() {
  set_has_blue_io();
  if (blue_io_ == NULL) blue_io_ = new ::Msg::GridGuildBaseIo;
  return blue_io_;
}
inline ::Msg::GridGuildBaseIo* BigMapWarHistory::release_blue_io() {
  clear_has_blue_io();
  ::Msg::GridGuildBaseIo* temp = blue_io_;
  blue_io_ = NULL;
  return temp;
}
inline void BigMapWarHistory::set_allocated_blue_io(::Msg::GridGuildBaseIo* blue_io) {
  delete blue_io_;
  blue_io_ = blue_io;
  if (blue_io) {
    set_has_blue_io();
  } else {
    clear_has_blue_io();
  }
}

// required .Msg.Ident winner_id = 10;
inline bool BigMapWarHistory::has_winner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapWarHistory::set_has_winner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapWarHistory::clear_has_winner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapWarHistory::clear_winner_id() {
  if (winner_id_ != NULL) winner_id_->::Msg::Ident::Clear();
  clear_has_winner_id();
}
inline const ::Msg::Ident& BigMapWarHistory::winner_id() const {
  return winner_id_ != NULL ? *winner_id_ : *default_instance_->winner_id_;
}
inline ::Msg::Ident* BigMapWarHistory::mutable_winner_id() {
  set_has_winner_id();
  if (winner_id_ == NULL) winner_id_ = new ::Msg::Ident;
  return winner_id_;
}
inline ::Msg::Ident* BigMapWarHistory::release_winner_id() {
  clear_has_winner_id();
  ::Msg::Ident* temp = winner_id_;
  winner_id_ = NULL;
  return temp;
}
inline void BigMapWarHistory::set_allocated_winner_id(::Msg::Ident* winner_id) {
  delete winner_id_;
  winner_id_ = winner_id;
  if (winner_id) {
    set_has_winner_id();
  } else {
    clear_has_winner_id();
  }
}

// required int32 war_time = 11;
inline bool BigMapWarHistory::has_war_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigMapWarHistory::set_has_war_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigMapWarHistory::clear_has_war_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigMapWarHistory::clear_war_time() {
  war_time_ = 0;
  clear_has_war_time();
}
inline ::google::protobuf::int32 BigMapWarHistory::war_time() const {
  return war_time_;
}
inline void BigMapWarHistory::set_war_time(::google::protobuf::int32 value) {
  set_has_war_time();
  war_time_ = value;
}

// -------------------------------------------------------------------

// BigMapGridDetailIo

// required .Msg.BigMapGridBaseIo grid_base_io = 1;
inline bool BigMapGridDetailIo::has_grid_base_io() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapGridDetailIo::set_has_grid_base_io() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapGridDetailIo::clear_has_grid_base_io() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapGridDetailIo::clear_grid_base_io() {
  if (grid_base_io_ != NULL) grid_base_io_->::Msg::BigMapGridBaseIo::Clear();
  clear_has_grid_base_io();
}
inline const ::Msg::BigMapGridBaseIo& BigMapGridDetailIo::grid_base_io() const {
  return grid_base_io_ != NULL ? *grid_base_io_ : *default_instance_->grid_base_io_;
}
inline ::Msg::BigMapGridBaseIo* BigMapGridDetailIo::mutable_grid_base_io() {
  set_has_grid_base_io();
  if (grid_base_io_ == NULL) grid_base_io_ = new ::Msg::BigMapGridBaseIo;
  return grid_base_io_;
}
inline ::Msg::BigMapGridBaseIo* BigMapGridDetailIo::release_grid_base_io() {
  clear_has_grid_base_io();
  ::Msg::BigMapGridBaseIo* temp = grid_base_io_;
  grid_base_io_ = NULL;
  return temp;
}
inline void BigMapGridDetailIo::set_allocated_grid_base_io(::Msg::BigMapGridBaseIo* grid_base_io) {
  delete grid_base_io_;
  grid_base_io_ = grid_base_io;
  if (grid_base_io) {
    set_has_grid_base_io();
  } else {
    clear_has_grid_base_io();
  }
}

// repeated .Msg.GridGuildBaseIo stay_guid_list = 2;
inline int BigMapGridDetailIo::stay_guid_list_size() const {
  return stay_guid_list_.size();
}
inline void BigMapGridDetailIo::clear_stay_guid_list() {
  stay_guid_list_.Clear();
}
inline const ::Msg::GridGuildBaseIo& BigMapGridDetailIo::stay_guid_list(int index) const {
  return stay_guid_list_.Get(index);
}
inline ::Msg::GridGuildBaseIo* BigMapGridDetailIo::mutable_stay_guid_list(int index) {
  return stay_guid_list_.Mutable(index);
}
inline ::Msg::GridGuildBaseIo* BigMapGridDetailIo::add_stay_guid_list() {
  return stay_guid_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::GridGuildBaseIo >&
BigMapGridDetailIo::stay_guid_list() const {
  return stay_guid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::GridGuildBaseIo >*
BigMapGridDetailIo::mutable_stay_guid_list() {
  return &stay_guid_list_;
}

// repeated .Msg.BigMapLeaveMsg leave_msg = 3;
inline int BigMapGridDetailIo::leave_msg_size() const {
  return leave_msg_.size();
}
inline void BigMapGridDetailIo::clear_leave_msg() {
  leave_msg_.Clear();
}
inline const ::Msg::BigMapLeaveMsg& BigMapGridDetailIo::leave_msg(int index) const {
  return leave_msg_.Get(index);
}
inline ::Msg::BigMapLeaveMsg* BigMapGridDetailIo::mutable_leave_msg(int index) {
  return leave_msg_.Mutable(index);
}
inline ::Msg::BigMapLeaveMsg* BigMapGridDetailIo::add_leave_msg() {
  return leave_msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapLeaveMsg >&
BigMapGridDetailIo::leave_msg() const {
  return leave_msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapLeaveMsg >*
BigMapGridDetailIo::mutable_leave_msg() {
  return &leave_msg_;
}

// repeated .Msg.BigMapWarHistory war_history = 4;
inline int BigMapGridDetailIo::war_history_size() const {
  return war_history_.size();
}
inline void BigMapGridDetailIo::clear_war_history() {
  war_history_.Clear();
}
inline const ::Msg::BigMapWarHistory& BigMapGridDetailIo::war_history(int index) const {
  return war_history_.Get(index);
}
inline ::Msg::BigMapWarHistory* BigMapGridDetailIo::mutable_war_history(int index) {
  return war_history_.Mutable(index);
}
inline ::Msg::BigMapWarHistory* BigMapGridDetailIo::add_war_history() {
  return war_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapWarHistory >&
BigMapGridDetailIo::war_history() const {
  return war_history_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapWarHistory >*
BigMapGridDetailIo::mutable_war_history() {
  return &war_history_;
}

// -------------------------------------------------------------------

// AckBigMapGridIo

// repeated .Msg.BigMapGridDetailIo map_data = 1;
inline int AckBigMapGridIo::map_data_size() const {
  return map_data_.size();
}
inline void AckBigMapGridIo::clear_map_data() {
  map_data_.Clear();
}
inline const ::Msg::BigMapGridDetailIo& AckBigMapGridIo::map_data(int index) const {
  return map_data_.Get(index);
}
inline ::Msg::BigMapGridDetailIo* AckBigMapGridIo::mutable_map_data(int index) {
  return map_data_.Mutable(index);
}
inline ::Msg::BigMapGridDetailIo* AckBigMapGridIo::add_map_data() {
  return map_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridDetailIo >&
AckBigMapGridIo::map_data() const {
  return map_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridDetailIo >*
AckBigMapGridIo::mutable_map_data() {
  return &map_data_;
}

// -------------------------------------------------------------------

// ReqBigMapIo

// -------------------------------------------------------------------

// AckBigMapIo

// repeated .Msg.BigMapGridBaseIo grid_base_io = 1;
inline int AckBigMapIo::grid_base_io_size() const {
  return grid_base_io_.size();
}
inline void AckBigMapIo::clear_grid_base_io() {
  grid_base_io_.Clear();
}
inline const ::Msg::BigMapGridBaseIo& AckBigMapIo::grid_base_io(int index) const {
  return grid_base_io_.Get(index);
}
inline ::Msg::BigMapGridBaseIo* AckBigMapIo::mutable_grid_base_io(int index) {
  return grid_base_io_.Mutable(index);
}
inline ::Msg::BigMapGridBaseIo* AckBigMapIo::add_grid_base_io() {
  return grid_base_io_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridBaseIo >&
AckBigMapIo::grid_base_io() const {
  return grid_base_io_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::BigMapGridBaseIo >*
AckBigMapIo::mutable_grid_base_io() {
  return &grid_base_io_;
}

// -------------------------------------------------------------------

// ReqHoldMapGrid

// required bytes map_title_id = 1;
inline bool ReqHoldMapGrid::has_map_title_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHoldMapGrid::set_has_map_title_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHoldMapGrid::clear_has_map_title_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHoldMapGrid::clear_map_title_id() {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    map_title_id_->clear();
  }
  clear_has_map_title_id();
}
inline const ::std::string& ReqHoldMapGrid::map_title_id() const {
  return *map_title_id_;
}
inline void ReqHoldMapGrid::set_map_title_id(const ::std::string& value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqHoldMapGrid::set_map_title_id(const char* value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqHoldMapGrid::set_map_title_id(const void* value, size_t size) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqHoldMapGrid::mutable_map_title_id() {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  return map_title_id_;
}
inline ::std::string* ReqHoldMapGrid::release_map_title_id() {
  clear_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_title_id_;
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqHoldMapGrid::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    delete map_title_id_;
  }
  if (map_title_id) {
    set_has_map_title_id();
    map_title_id_ = map_title_id;
  } else {
    clear_has_map_title_id();
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.Ident guild_id = 2;
inline bool ReqHoldMapGrid::has_guild_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqHoldMapGrid::set_has_guild_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqHoldMapGrid::clear_has_guild_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqHoldMapGrid::clear_guild_id() {
  if (guild_id_ != NULL) guild_id_->::Msg::Ident::Clear();
  clear_has_guild_id();
}
inline const ::Msg::Ident& ReqHoldMapGrid::guild_id() const {
  return guild_id_ != NULL ? *guild_id_ : *default_instance_->guild_id_;
}
inline ::Msg::Ident* ReqHoldMapGrid::mutable_guild_id() {
  set_has_guild_id();
  if (guild_id_ == NULL) guild_id_ = new ::Msg::Ident;
  return guild_id_;
}
inline ::Msg::Ident* ReqHoldMapGrid::release_guild_id() {
  clear_has_guild_id();
  ::Msg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline void ReqHoldMapGrid::set_allocated_guild_id(::Msg::Ident* guild_id) {
  delete guild_id_;
  guild_id_ = guild_id;
  if (guild_id) {
    set_has_guild_id();
  } else {
    clear_has_guild_id();
  }
}

// -------------------------------------------------------------------

// AckHoldMapGrid

// -------------------------------------------------------------------

// ReqLeaveMapMsg

// required bytes map_title_id = 1;
inline bool ReqLeaveMapMsg::has_map_title_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLeaveMapMsg::set_has_map_title_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLeaveMapMsg::clear_has_map_title_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLeaveMapMsg::clear_map_title_id() {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    map_title_id_->clear();
  }
  clear_has_map_title_id();
}
inline const ::std::string& ReqLeaveMapMsg::map_title_id() const {
  return *map_title_id_;
}
inline void ReqLeaveMapMsg::set_map_title_id(const ::std::string& value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqLeaveMapMsg::set_map_title_id(const char* value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqLeaveMapMsg::set_map_title_id(const void* value, size_t size) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLeaveMapMsg::mutable_map_title_id() {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  return map_title_id_;
}
inline ::std::string* ReqLeaveMapMsg::release_map_title_id() {
  clear_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_title_id_;
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLeaveMapMsg::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    delete map_title_id_;
  }
  if (map_title_id) {
    set_has_map_title_id();
    map_title_id_ = map_title_id;
  } else {
    clear_has_map_title_id();
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Msg.BigMapLeaveMsg leave_msg = 2;
inline bool ReqLeaveMapMsg::has_leave_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLeaveMapMsg::set_has_leave_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLeaveMapMsg::clear_has_leave_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLeaveMapMsg::clear_leave_msg() {
  if (leave_msg_ != NULL) leave_msg_->::Msg::BigMapLeaveMsg::Clear();
  clear_has_leave_msg();
}
inline const ::Msg::BigMapLeaveMsg& ReqLeaveMapMsg::leave_msg() const {
  return leave_msg_ != NULL ? *leave_msg_ : *default_instance_->leave_msg_;
}
inline ::Msg::BigMapLeaveMsg* ReqLeaveMapMsg::mutable_leave_msg() {
  set_has_leave_msg();
  if (leave_msg_ == NULL) leave_msg_ = new ::Msg::BigMapLeaveMsg;
  return leave_msg_;
}
inline ::Msg::BigMapLeaveMsg* ReqLeaveMapMsg::release_leave_msg() {
  clear_has_leave_msg();
  ::Msg::BigMapLeaveMsg* temp = leave_msg_;
  leave_msg_ = NULL;
  return temp;
}
inline void ReqLeaveMapMsg::set_allocated_leave_msg(::Msg::BigMapLeaveMsg* leave_msg) {
  delete leave_msg_;
  leave_msg_ = leave_msg;
  if (leave_msg) {
    set_has_leave_msg();
  } else {
    clear_has_leave_msg();
  }
}

// -------------------------------------------------------------------

// AckLeaveMapMsg

// -------------------------------------------------------------------

// ReqGetMapAward

// required bytes map_title_id = 1;
inline bool ReqGetMapAward::has_map_title_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetMapAward::set_has_map_title_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetMapAward::clear_has_map_title_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetMapAward::clear_map_title_id() {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    map_title_id_->clear();
  }
  clear_has_map_title_id();
}
inline const ::std::string& ReqGetMapAward::map_title_id() const {
  return *map_title_id_;
}
inline void ReqGetMapAward::set_map_title_id(const ::std::string& value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqGetMapAward::set_map_title_id(const char* value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqGetMapAward::set_map_title_id(const void* value, size_t size) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGetMapAward::mutable_map_title_id() {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  return map_title_id_;
}
inline ::std::string* ReqGetMapAward::release_map_title_id() {
  clear_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_title_id_;
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqGetMapAward::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    delete map_title_id_;
  }
  if (map_title_id) {
    set_has_map_title_id();
    map_title_id_ = map_title_id;
  } else {
    clear_has_map_title_id();
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGetMapAward

// -------------------------------------------------------------------

// ReqMapHunting

// required bytes map_title_id = 1;
inline bool ReqMapHunting::has_map_title_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMapHunting::set_has_map_title_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMapHunting::clear_has_map_title_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMapHunting::clear_map_title_id() {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    map_title_id_->clear();
  }
  clear_has_map_title_id();
}
inline const ::std::string& ReqMapHunting::map_title_id() const {
  return *map_title_id_;
}
inline void ReqMapHunting::set_map_title_id(const ::std::string& value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqMapHunting::set_map_title_id(const char* value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqMapHunting::set_map_title_id(const void* value, size_t size) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqMapHunting::mutable_map_title_id() {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  return map_title_id_;
}
inline ::std::string* ReqMapHunting::release_map_title_id() {
  clear_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_title_id_;
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqMapHunting::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    delete map_title_id_;
  }
  if (map_title_id) {
    set_has_map_title_id();
    map_title_id_ = map_title_id;
  } else {
    clear_has_map_title_id();
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckMapHunting

// -------------------------------------------------------------------

// ReqMapKingWar

// required bytes map_title_id = 1;
inline bool ReqMapKingWar::has_map_title_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMapKingWar::set_has_map_title_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMapKingWar::clear_has_map_title_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMapKingWar::clear_map_title_id() {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    map_title_id_->clear();
  }
  clear_has_map_title_id();
}
inline const ::std::string& ReqMapKingWar::map_title_id() const {
  return *map_title_id_;
}
inline void ReqMapKingWar::set_map_title_id(const ::std::string& value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqMapKingWar::set_map_title_id(const char* value) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(value);
}
inline void ReqMapKingWar::set_map_title_id(const void* value, size_t size) {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  map_title_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqMapKingWar::mutable_map_title_id() {
  set_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    map_title_id_ = new ::std::string;
  }
  return map_title_id_;
}
inline ::std::string* ReqMapKingWar::release_map_title_id() {
  clear_has_map_title_id();
  if (map_title_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_title_id_;
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqMapKingWar::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id_ != &::google::protobuf::internal::kEmptyString) {
    delete map_title_id_;
  }
  if (map_title_id) {
    set_has_map_title_id();
    map_title_id_ = map_title_id;
  } else {
    clear_has_map_title_id();
    map_title_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckMapKingWar

// -------------------------------------------------------------------

// PVPRoomIo

// required int32 nCellStatus = 1;
inline bool PVPRoomIo::has_ncellstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVPRoomIo::set_has_ncellstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVPRoomIo::clear_has_ncellstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVPRoomIo::clear_ncellstatus() {
  ncellstatus_ = 0;
  clear_has_ncellstatus();
}
inline ::google::protobuf::int32 PVPRoomIo::ncellstatus() const {
  return ncellstatus_;
}
inline void PVPRoomIo::set_ncellstatus(::google::protobuf::int32 value) {
  set_has_ncellstatus();
  ncellstatus_ = value;
}

// required .Msg.Ident RoomID = 2;
inline bool PVPRoomIo::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVPRoomIo::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVPRoomIo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVPRoomIo::clear_roomid() {
  if (roomid_ != NULL) roomid_->::Msg::Ident::Clear();
  clear_has_roomid();
}
inline const ::Msg::Ident& PVPRoomIo::roomid() const {
  return roomid_ != NULL ? *roomid_ : *default_instance_->roomid_;
}
inline ::Msg::Ident* PVPRoomIo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == NULL) roomid_ = new ::Msg::Ident;
  return roomid_;
}
inline ::Msg::Ident* PVPRoomIo::release_roomid() {
  clear_has_roomid();
  ::Msg::Ident* temp = roomid_;
  roomid_ = NULL;
  return temp;
}
inline void PVPRoomIo::set_allocated_roomid(::Msg::Ident* roomid) {
  delete roomid_;
  roomid_ = roomid;
  if (roomid) {
    set_has_roomid();
  } else {
    clear_has_roomid();
  }
}

// required int32 nPVPMode = 3;
inline bool PVPRoomIo::has_npvpmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVPRoomIo::set_has_npvpmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVPRoomIo::clear_has_npvpmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVPRoomIo::clear_npvpmode() {
  npvpmode_ = 0;
  clear_has_npvpmode();
}
inline ::google::protobuf::int32 PVPRoomIo::npvpmode() const {
  return npvpmode_;
}
inline void PVPRoomIo::set_npvpmode(::google::protobuf::int32 value) {
  set_has_npvpmode();
  npvpmode_ = value;
}

// required int32 nPVPGrade = 4;
inline bool PVPRoomIo::has_npvpgrade() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVPRoomIo::set_has_npvpgrade() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVPRoomIo::clear_has_npvpgrade() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PVPRoomIo::clear_npvpgrade() {
  npvpgrade_ = 0;
  clear_has_npvpgrade();
}
inline ::google::protobuf::int32 PVPRoomIo::npvpgrade() const {
  return npvpgrade_;
}
inline void PVPRoomIo::set_npvpgrade(::google::protobuf::int32 value) {
  set_has_npvpgrade();
  npvpgrade_ = value;
}

// required int32 MaxPalyer = 5;
inline bool PVPRoomIo::has_maxpalyer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PVPRoomIo::set_has_maxpalyer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PVPRoomIo::clear_has_maxpalyer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PVPRoomIo::clear_maxpalyer() {
  maxpalyer_ = 0;
  clear_has_maxpalyer();
}
inline ::google::protobuf::int32 PVPRoomIo::maxpalyer() const {
  return maxpalyer_;
}
inline void PVPRoomIo::set_maxpalyer(::google::protobuf::int32 value) {
  set_has_maxpalyer();
  maxpalyer_ = value;
}

// repeated .Msg.Ident xRedPlayer = 6;
inline int PVPRoomIo::xredplayer_size() const {
  return xredplayer_.size();
}
inline void PVPRoomIo::clear_xredplayer() {
  xredplayer_.Clear();
}
inline const ::Msg::Ident& PVPRoomIo::xredplayer(int index) const {
  return xredplayer_.Get(index);
}
inline ::Msg::Ident* PVPRoomIo::mutable_xredplayer(int index) {
  return xredplayer_.Mutable(index);
}
inline ::Msg::Ident* PVPRoomIo::add_xredplayer() {
  return xredplayer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
PVPRoomIo::xredplayer() const {
  return xredplayer_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
PVPRoomIo::mutable_xredplayer() {
  return &xredplayer_;
}

// repeated .Msg.Ident xBluePlayer = 7;
inline int PVPRoomIo::xblueplayer_size() const {
  return xblueplayer_.size();
}
inline void PVPRoomIo::clear_xblueplayer() {
  xblueplayer_.Clear();
}
inline const ::Msg::Ident& PVPRoomIo::xblueplayer(int index) const {
  return xblueplayer_.Get(index);
}
inline ::Msg::Ident* PVPRoomIo::mutable_xblueplayer(int index) {
  return xblueplayer_.Mutable(index);
}
inline ::Msg::Ident* PVPRoomIo::add_xblueplayer() {
  return xblueplayer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Msg::Ident >&
PVPRoomIo::xblueplayer() const {
  return xblueplayer_;
}
inline ::google::protobuf::RepeatedPtrField< ::Msg::Ident >*
PVPRoomIo::mutable_xblueplayer() {
  return &xblueplayer_;
}

// optional int64 serverid = 8;
inline bool PVPRoomIo::has_serverid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PVPRoomIo::set_has_serverid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PVPRoomIo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PVPRoomIo::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 PVPRoomIo::serverid() const {
  return serverid_;
}
inline void PVPRoomIo::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional int64 SceneID = 9;
inline bool PVPRoomIo::has_sceneid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PVPRoomIo::set_has_sceneid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PVPRoomIo::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PVPRoomIo::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(0);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 PVPRoomIo::sceneid() const {
  return sceneid_;
}
inline void PVPRoomIo::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// optional int64 groupID = 10;
inline bool PVPRoomIo::has_groupid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PVPRoomIo::set_has_groupid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PVPRoomIo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PVPRoomIo::clear_groupid() {
  groupid_ = GOOGLE_LONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::int64 PVPRoomIo::groupid() const {
  return groupid_;
}
inline void PVPRoomIo::set_groupid(::google::protobuf::int64 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// ReqPVPApplyMatch

// required .Msg.Ident self_id = 1;
inline bool ReqPVPApplyMatch::has_self_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPVPApplyMatch::set_has_self_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPVPApplyMatch::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPVPApplyMatch::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& ReqPVPApplyMatch::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* ReqPVPApplyMatch::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* ReqPVPApplyMatch::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void ReqPVPApplyMatch::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// required int32 nPVPMode = 2;
inline bool ReqPVPApplyMatch::has_npvpmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPVPApplyMatch::set_has_npvpmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPVPApplyMatch::clear_has_npvpmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPVPApplyMatch::clear_npvpmode() {
  npvpmode_ = 0;
  clear_has_npvpmode();
}
inline ::google::protobuf::int32 ReqPVPApplyMatch::npvpmode() const {
  return npvpmode_;
}
inline void ReqPVPApplyMatch::set_npvpmode(::google::protobuf::int32 value) {
  set_has_npvpmode();
  npvpmode_ = value;
}

// optional int64 score = 3;
inline bool ReqPVPApplyMatch::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqPVPApplyMatch::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqPVPApplyMatch::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqPVPApplyMatch::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::int64 ReqPVPApplyMatch::score() const {
  return score_;
}
inline void ReqPVPApplyMatch::set_score(::google::protobuf::int64 value) {
  set_has_score();
  score_ = value;
}

// required int32 ApplyType = 4;
inline bool ReqPVPApplyMatch::has_applytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqPVPApplyMatch::set_has_applytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqPVPApplyMatch::clear_has_applytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqPVPApplyMatch::clear_applytype() {
  applytype_ = 0;
  clear_has_applytype();
}
inline ::google::protobuf::int32 ReqPVPApplyMatch::applytype() const {
  return applytype_;
}
inline void ReqPVPApplyMatch::set_applytype(::google::protobuf::int32 value) {
  set_has_applytype();
  applytype_ = value;
}

// optional .Msg.Ident team_id = 5;
inline bool ReqPVPApplyMatch::has_team_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqPVPApplyMatch::set_has_team_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqPVPApplyMatch::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqPVPApplyMatch::clear_team_id() {
  if (team_id_ != NULL) team_id_->::Msg::Ident::Clear();
  clear_has_team_id();
}
inline const ::Msg::Ident& ReqPVPApplyMatch::team_id() const {
  return team_id_ != NULL ? *team_id_ : *default_instance_->team_id_;
}
inline ::Msg::Ident* ReqPVPApplyMatch::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == NULL) team_id_ = new ::Msg::Ident;
  return team_id_;
}
inline ::Msg::Ident* ReqPVPApplyMatch::release_team_id() {
  clear_has_team_id();
  ::Msg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline void ReqPVPApplyMatch::set_allocated_team_id(::Msg::Ident* team_id) {
  delete team_id_;
  team_id_ = team_id;
  if (team_id) {
    set_has_team_id();
  } else {
    clear_has_team_id();
  }
}

// -------------------------------------------------------------------

// AckPVPApplyMatch

// required .Msg.Ident self_id = 1;
inline bool AckPVPApplyMatch::has_self_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPVPApplyMatch::set_has_self_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPVPApplyMatch::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPVPApplyMatch::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& AckPVPApplyMatch::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* AckPVPApplyMatch::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* AckPVPApplyMatch::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void AckPVPApplyMatch::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// optional .Msg.PVPRoomIo xRoomIo = 2;
inline bool AckPVPApplyMatch::has_xroomio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPVPApplyMatch::set_has_xroomio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPVPApplyMatch::clear_has_xroomio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPVPApplyMatch::clear_xroomio() {
  if (xroomio_ != NULL) xroomio_->::Msg::PVPRoomIo::Clear();
  clear_has_xroomio();
}
inline const ::Msg::PVPRoomIo& AckPVPApplyMatch::xroomio() const {
  return xroomio_ != NULL ? *xroomio_ : *default_instance_->xroomio_;
}
inline ::Msg::PVPRoomIo* AckPVPApplyMatch::mutable_xroomio() {
  set_has_xroomio();
  if (xroomio_ == NULL) xroomio_ = new ::Msg::PVPRoomIo;
  return xroomio_;
}
inline ::Msg::PVPRoomIo* AckPVPApplyMatch::release_xroomio() {
  clear_has_xroomio();
  ::Msg::PVPRoomIo* temp = xroomio_;
  xroomio_ = NULL;
  return temp;
}
inline void AckPVPApplyMatch::set_allocated_xroomio(::Msg::PVPRoomIo* xroomio) {
  delete xroomio_;
  xroomio_ = xroomio;
  if (xroomio) {
    set_has_xroomio();
  } else {
    clear_has_xroomio();
  }
}

// required int32 ApplyType = 3;
inline bool AckPVPApplyMatch::has_applytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPVPApplyMatch::set_has_applytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPVPApplyMatch::clear_has_applytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPVPApplyMatch::clear_applytype() {
  applytype_ = 0;
  clear_has_applytype();
}
inline ::google::protobuf::int32 AckPVPApplyMatch::applytype() const {
  return applytype_;
}
inline void AckPVPApplyMatch::set_applytype(::google::protobuf::int32 value) {
  set_has_applytype();
  applytype_ = value;
}

// required int32 nResult = 4;
inline bool AckPVPApplyMatch::has_nresult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckPVPApplyMatch::set_has_nresult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckPVPApplyMatch::clear_has_nresult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckPVPApplyMatch::clear_nresult() {
  nresult_ = 0;
  clear_has_nresult();
}
inline ::google::protobuf::int32 AckPVPApplyMatch::nresult() const {
  return nresult_;
}
inline void AckPVPApplyMatch::set_nresult(::google::protobuf::int32 value) {
  set_has_nresult();
  nresult_ = value;
}

// -------------------------------------------------------------------

// ReqCreatePVPEctype

// required .Msg.Ident self_id = 1;
inline bool ReqCreatePVPEctype::has_self_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCreatePVPEctype::set_has_self_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCreatePVPEctype::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCreatePVPEctype::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& ReqCreatePVPEctype::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* ReqCreatePVPEctype::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* ReqCreatePVPEctype::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void ReqCreatePVPEctype::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// required .Msg.PVPRoomIo xRoomIo = 2;
inline bool ReqCreatePVPEctype::has_xroomio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCreatePVPEctype::set_has_xroomio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCreatePVPEctype::clear_has_xroomio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCreatePVPEctype::clear_xroomio() {
  if (xroomio_ != NULL) xroomio_->::Msg::PVPRoomIo::Clear();
  clear_has_xroomio();
}
inline const ::Msg::PVPRoomIo& ReqCreatePVPEctype::xroomio() const {
  return xroomio_ != NULL ? *xroomio_ : *default_instance_->xroomio_;
}
inline ::Msg::PVPRoomIo* ReqCreatePVPEctype::mutable_xroomio() {
  set_has_xroomio();
  if (xroomio_ == NULL) xroomio_ = new ::Msg::PVPRoomIo;
  return xroomio_;
}
inline ::Msg::PVPRoomIo* ReqCreatePVPEctype::release_xroomio() {
  clear_has_xroomio();
  ::Msg::PVPRoomIo* temp = xroomio_;
  xroomio_ = NULL;
  return temp;
}
inline void ReqCreatePVPEctype::set_allocated_xroomio(::Msg::PVPRoomIo* xroomio) {
  delete xroomio_;
  xroomio_ = xroomio;
  if (xroomio) {
    set_has_xroomio();
  } else {
    clear_has_xroomio();
  }
}

// -------------------------------------------------------------------

// AckCreatePVPEctype

// required .Msg.Ident self_id = 1;
inline bool AckCreatePVPEctype::has_self_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckCreatePVPEctype::set_has_self_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckCreatePVPEctype::clear_has_self_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckCreatePVPEctype::clear_self_id() {
  if (self_id_ != NULL) self_id_->::Msg::Ident::Clear();
  clear_has_self_id();
}
inline const ::Msg::Ident& AckCreatePVPEctype::self_id() const {
  return self_id_ != NULL ? *self_id_ : *default_instance_->self_id_;
}
inline ::Msg::Ident* AckCreatePVPEctype::mutable_self_id() {
  set_has_self_id();
  if (self_id_ == NULL) self_id_ = new ::Msg::Ident;
  return self_id_;
}
inline ::Msg::Ident* AckCreatePVPEctype::release_self_id() {
  clear_has_self_id();
  ::Msg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline void AckCreatePVPEctype::set_allocated_self_id(::Msg::Ident* self_id) {
  delete self_id_;
  self_id_ = self_id;
  if (self_id) {
    set_has_self_id();
  } else {
    clear_has_self_id();
  }
}

// required .Msg.PVPRoomIo xRoomIo = 2;
inline bool AckCreatePVPEctype::has_xroomio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckCreatePVPEctype::set_has_xroomio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckCreatePVPEctype::clear_has_xroomio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckCreatePVPEctype::clear_xroomio() {
  if (xroomio_ != NULL) xroomio_->::Msg::PVPRoomIo::Clear();
  clear_has_xroomio();
}
inline const ::Msg::PVPRoomIo& AckCreatePVPEctype::xroomio() const {
  return xroomio_ != NULL ? *xroomio_ : *default_instance_->xroomio_;
}
inline ::Msg::PVPRoomIo* AckCreatePVPEctype::mutable_xroomio() {
  set_has_xroomio();
  if (xroomio_ == NULL) xroomio_ = new ::Msg::PVPRoomIo;
  return xroomio_;
}
inline ::Msg::PVPRoomIo* AckCreatePVPEctype::release_xroomio() {
  clear_has_xroomio();
  ::Msg::PVPRoomIo* temp = xroomio_;
  xroomio_ = NULL;
  return temp;
}
inline void AckCreatePVPEctype::set_allocated_xroomio(::Msg::PVPRoomIo* xroomio) {
  delete xroomio_;
  xroomio_ = xroomio;
  if (xroomio) {
    set_has_xroomio();
  } else {
    clear_has_xroomio();
  }
}

// required int32 ApplyType = 3;
inline bool AckCreatePVPEctype::has_applytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckCreatePVPEctype::set_has_applytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckCreatePVPEctype::clear_has_applytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckCreatePVPEctype::clear_applytype() {
  applytype_ = 0;
  clear_has_applytype();
}
inline ::google::protobuf::int32 AckCreatePVPEctype::applytype() const {
  return applytype_;
}
inline void AckCreatePVPEctype::set_applytype(::google::protobuf::int32 value) {
  set_has_applytype();
  applytype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckSynData_SynType>() {
  return ::Msg::ReqAckSynData_SynType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckPlayerChat_ChatContainer_ContainerType>() {
  return ::Msg::ReqAckPlayerChat_ChatContainer_ContainerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckPlayerChat_EGameChatType>() {
  return ::Msg::ReqAckPlayerChat_EGameChatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::EffectData_EResultType>() {
  return ::Msg::EffectData_EResultType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckSwapScene_EGameSwapType>() {
  return ::Msg::ReqAckSwapScene_EGameSwapType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckJoinActivity_EGameActivityType>() {
  return ::Msg::ReqAckJoinActivity_EGameActivityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckJoinActivity_EGameActivitySubType>() {
  return ::Msg::ReqAckJoinActivity_EGameActivitySubType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckOprGuildMember_EGGuildMemberOprType>() {
  return ::Msg::ReqAckOprGuildMember_EGGuildMemberOprType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqAckOprTeamMember_EGTeamMemberOprType>() {
  return ::Msg::ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg::ReqPVPApplyMatch_EApplyType>() {
  return ::Msg::ReqPVPApplyMatch_EApplyType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgShare_2eproto__INCLUDED
